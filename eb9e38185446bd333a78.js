(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{293:function(n,l,t){},302:function(n,l,t){var map={"./CommonJS、AMD、CMD、ES6.md":303,"./Hexo-修改文章链接的默认格式.md":304,"./VSCode之git插件显示当前commit信息.md":305,"./git知多少.md":306,"./js中全等和等于.md":307,"./js基本数据类型和引用数据类型的区别.md":308,"./js常用正则验证.md":309,"./js数组去重.md":310,"./js数组排序.md":311,"./js日期格式化.md":312,"./js深浅拷贝.md":313,"./js闭包.md":314,"./vue.filter自定义过滤器.md":315,"./vue.sync修饰符.md":316,"./vue中将html字符串转换成html遇到的小问题.md":317,"./vue函数式组件.md":318,"./vue指令.md":319,"./vue组件开发props验证.md":320,"./vue组件的data为什么是函数而不是对象.md":321,"./vue自定义指令.md":322,"./严格模式.md":323,"./前端常问面试题.md":324,"./封装promise.md":325,"./正则.md":326,"./程序员语录.md":327,"./翻墙YouTube看不停.md":328,"./节流throttle.md":329,"./防抖debounce.md":330};function e(n){var l=c(n);return t(l)}function c(n){if(!t.o(map,n)){var l=new Error("Cannot find module '"+n+"'");throw l.code="MODULE_NOT_FOUND",l}return map[n]}e.keys=function(){return Object.keys(map)},e.resolve=c,n.exports=e,e.id=302},303:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: CommonJS、AMD、CMD、ES6,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: javascript,\ndate: 2019-04-08 19:47:28,\navatar: ,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n\x3c!-- ![](https://user-gold-cdn.xitu.io/2018/12/16/167b650e8d1fcc23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  --\x3e\n<h2><font color=＃409EFF> 前端模块化：CommonJs、AMD、CMD、ES6 </font></h2>\n<h4><font color=#00ffff> 模块化的好处： </font></h4>\n<p>模块化的开发可以提升代码的可复用性，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD、以及ES6的模块系统。</p>\n<h3>一、CommonJs</h3>\n<p>node.js是commonJS规范的主要实践者，它有四个重要的环境变量位为模块化的实现提供支持：         <font color=red>module、exports、require、global</font>。实际使用时，用module.exports定义当前模块对外输出的接口(不推荐直接用exports)，用require加载模块。</p>\n<pre><code class="language-js"><span class="hljs-comment">//定义模块math.js</span>\n<span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>{\n    <span class="hljs-keyword">return</span> a + b;\n}\n<span class="hljs-built_in">module</span>.exports = { <span class="hljs-comment">//在这里写需要向外暴露的函数、变量</span>\n    add:add,\n    num\n}\n<span class="hljs-comment">//引用自定义的模块时，参数包含路径，可省略.js</span>\n<span class="hljs-keyword">var</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./math\'</span>)\nmath.add(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//7</span>\n\n<span class="hljs-comment">//引用node-module包时，不需要带路径</span>\n<span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>)\nhttp.createService(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{\n\n}).listen(<span class="hljs-number">3000</span>)\n</code></pre>\n<p>CommonJS用同步的方法加载模块。在服务端，模块文化都存在本地磁盘，读取速度非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>\n<h2>二、AMD和require.js</h2>\n<p>AMD规范采用异步方式加载模块，模块的加载不影响它后面的语句运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍require.js实现AMD规范的模块化：用<font color=red>require.config()</font>指定引用路径等，用<font color=red>define()</font>定义模块，用<font color=red>require()</font>加载模块。\n首先我们需要引入require.js文件和一个入口文件main.js中配置<font color=red>require.config()</font>并规定项目中用到等基础模块</p>\n<pre><code class="language-js"><span class="hljs-comment">/*网页中引入ruire.js及main.js*/</span>\n&lt;script src=<span class="hljs-string">"require.js"</span> data-main=<span class="hljs-string">"js/main"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>\n<span class="hljs-comment">/* main.js 入口文件/主模块*/</span>\n<span class="hljs-built_in">require</span>.config({\n    <span class="hljs-attr">baseUrl</span>: <span class="hljs-string">"js/lib"</span>, <span class="hljs-comment">//基路径</span>\n    path:{\n        <span class="hljs-string">"jquery"</span>:<span class="hljs-string">"jquery.min"</span>, <span class="hljs-comment">//实际路径js/lib/jquery.min.js</span>\n        <span class="hljs-string">"underscore"</span>:<span class="hljs-string">"underscore.min"</span>\n    }\n});\n<span class="hljs-comment">// 执行基本操作</span>\n<span class="hljs-built_in">require</span>([<span class="hljs-string">"jquery"</span>,<span class="hljs-string">"underscore"</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$,un</span>)</span>{\n    <span class="hljs-comment">//some code here</span>\n})\n</code></pre>\n<p>引用模块的时候，我们将模块名放在<font color=red>[]</font>中作为<font color=red>require()</font>的第一个参数；如果我们定义的模块本身也依赖其他模块，那就需要将他们放在<font color=red>[]</font>中作为<font color=red>define()</font>的第一个参数。</p>\n<pre><code class="language-js">    <span class="hljs-comment">//定义math.js</span>\n    define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n        <span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>)</span>{\n            <span class="hljs-keyword">return</span> x + y;\n        };\n        <span class="hljs-keyword">return</span> {\n            <span class="hljs-attr">add</span>: add,\n            <span class="hljs-attr">basicNum</span>: basicNum\n        };\n    });\n    <span class="hljs-comment">//定义一个依赖underscore.js 模块</span>\n    defind([<span class="hljs-string">\'underscore\'</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nu</span>)</span>{\n        <span class="hljs-keyword">var</span> classify = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list</span>)</span>{\n            nu.conntBy(list,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)</span>{\n                <span class="hljs-keyword">return</span> num &gt; <span class="hljs-number">30</span> ? <span class="hljs-string">\'old\'</span> : <span class="hljs-string">\'young\'</span>;\n            })\n        };\n        <span class="hljs-keyword">return</span>{\n            <span class="hljs-attr">classify</span>: classify\n        };\n    })\n    <span class="hljs-comment">//引用模块，将模块放在[]内</span>\n    <span class="hljs-built_in">require</span>([<span class="hljs-string">\'jquery\'</span>,<span class="hljs-string">\'math\'</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$,m</span>)</span>{\n        <span class="hljs-keyword">var</span> sum = math.add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);\n        $(<span class="hljs-string">"#box"</span>).html(sum)\n    });\n</code></pre>\n<h1>三、CMD和sea.js</h1>\n<p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p>\n<pre><code class="language-js">    define([<span class="hljs-string">\'a\'</span>,<span class="hljs-string">\'b\'</span>,<span class="hljs-string">\'c\'</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,c</span>)</span>{\n        <span class="hljs-comment">//在最前面声明并初始化了要用到的所有模块</span>\n        <span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span>){\n            <span class="hljs-comment">//即便没用到某个模块，b 但在声明 b 时已经提前执行了</span>\n            b.foo()\n        }\n    })\n</code></pre>\n<p>CMD是另一种js模块化方案，它于AMD很类似，不同点在于：AMD推崇依赖前置、提前执行，CMD推崇就近、延迟执行。此规范其实是在sea.js推广过程中产出的</p>\n<pre><code class="language-js"><span class="hljs-comment">//AMD写法</span>\n define([<span class="hljs-string">\'a\'</span>,<span class="hljs-string">\'b\'</span>,<span class="hljs-string">\'c\'</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,c</span>)</span>{\n        <span class="hljs-comment">//在最前面声明并初始化了要用到的所有模块</span>\n        <span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span>){\n            <span class="hljs-comment">//即便没用到某个模块，b 但在声明 b 时已经提前执行了</span>\n            b.foo()\n        }\n    })\n<span class="hljs-comment">//CMD写法 </span>\n<span class="hljs-comment">// 定义模块 math.js</span>\ndefine(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,export,module</span>)</span>{\n    <span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'jquery\'</span>);\n    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>{\n        <span class="hljs-keyword">return</span> a + b;\n    }\n    exports.add = add;\n})\n<span class="hljs-comment">//加载模块</span>\nseajs.use([<span class="hljs-string">\'math.js\'</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">math</span>)</span>{\n    <span class="hljs-keyword">var</span> sum = math.add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)\n})\n</code></pre>\n<h1>AMD与CMD - 真正的不同 还是执行时间</h1>\n<pre><code class="language-js"><span class="hljs-comment">// AMD recommended</span>\ndefine([<span class="hljs-string">\'a\'</span>, <span class="hljs-string">\'b\'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>)</span>{\n    a.doSomething();    <span class="hljs-comment">// 依赖前置，提前执行</span>\n    b.doSomething();\n})\n\n<span class="hljs-comment">// CMD recommanded</span>\ndefine(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require, exports, module</span>)</span>{\n    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">"a"</span>);\n    a.doSomething();\n    <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">"b"</span>);\n    b.doSomething();    <span class="hljs-comment">// 依赖就近，延迟执行</span>\n})\n</code></pre>\n<h1>四、ES6 Module</h1>\n<p>ES6在语言标准的层面上，实现了模块功能，而且实现的相当简单，只为成为浏览器和服务器通用的模块定义方案。其模块功能主要由两个命令构成：<font color=red>export</font>和<font color=red>import</font>。<font color=red>export</font>命令用于规定模块的对外接口，<font color=red>import</font>命令用于输入其他模块提供的功能。</p>\n<pre><code class="language-js">    <span class="hljs-comment">/** 定义模块 math.js **/</span>\n    <span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>\n    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>{\n        <span class="hljs-keyword">return</span> a + b; \n    };\n    <span class="hljs-keyword">export</span> {basicNum, add};\n\n    <span class="hljs-comment">// 抛出变量</span>\n    <span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> PI = <span class="hljs-number">3.14</span>;\n    <span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> bar = foo; \n\n    <span class="hljs-comment">//抛出 函数</span>\n    <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'I am not bar.\'</span>);\n    }\n\n    <span class="hljs-comment">//默认抛出 一个js文件只能有一个默认抛出</span>\n    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (a, b)=&gt;{\n        <span class="hljs-keyword">return</span> a + b\n    }\n\n    <span class="hljs-comment">/** 引用模块 **/</span>\n    <span class="hljs-keyword">import</span>{basicNum, add } <span class="hljs-keyword">from</span> <span class="hljs-string">\'./math\'</span>;\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">el</span>)</span>{\n        el.innerHTML = add(<span class="hljs-number">1</span>,basicNum);\n    }\n\n    <span class="hljs-keyword">import</span> { foo <span class="hljs-keyword">as</span> bar } <span class="hljs-keyword">from</span> <span class="hljs-string">"./math"</span>; <span class="hljs-comment">//as 设置别名</span>\n    bar(); \n\n    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">"./math"</span>; <span class="hljs-comment">//*所有抛出 都配置到 math身上</span>\n    math.PI\n    math.foo()\n\n</code></pre>\n<p>如上例所示，使用<font color=red>import</font>命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了<font color=red>export default</font> 命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。</p>\n<h1>五、 ES6 模块与 CommonJS 模块的差异</h1>\n<h4>1. CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用。</h4>\n<ul>\n<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<font color=red>import</font>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<font color=red>import</font>有点像 Unix 系统的“符号连接”，原始值变了，<font color=red>import</font>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>\n</ul>\n<h4>2. CommonJS模块是运行时加载，ES6模块是在编译时输出接口</h4>\n<ul>\n<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>\n<li>编译时加载: ES6 模块不是对象，而是通过  <font color=red>export</font> 命令显式指定输出的代码， <font color=red>import </font>时采用静态命令的形式。即在 <font color=red>import</font>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>\n</ul>\n<p>CommonJS 加载的是一个对象（即<font color=red>module.exports</font>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>\n<p><font color=red></font></p>\n</section>\n'},304:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: Hexo-修改文章链接的默认格式,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: javascript,\ndate: 2019-05-08 14:40:19,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<p>Hexo的永久链接的默认格式是 <code>:year/:month/:day/:title/</code>，比如访问站点下某一篇文章时，其路径是 <code>2018/04/12/xxxx/</code>，如果我们的文章标题是中文的，那么该路径就会出现中文字符。在路径中出现了中文字符很容易引发各种问题，而且也不利于seo，因为路径包含了年月日三个层级，层级太深不利于百度蜘蛛抓取。</p>\n<p>解决办法就是利用其它的插件来生成唯一的路径，这样就算我们的文件标题随意修改，而不会导致原本的链接失效而造成站点下存在大量的死链。</p>\n<h3>安装插件</h3>\n<p>在站点根目录使用 git bash 执行命令：</p>\n<p>npm install hexo-abbrlink --save</p>\n<h3>修改站点配置文件</h3>\n<p>打开根目录下的 _config.yml 文件，修改如下配置：</p>\n<pre><code class="language-json"># permalink: :year/:month/:day/:title/\n# permalink_defaults:\npermalink: :year/:abbrlink.html\nabbrlink:\n  alg: crc<span class="hljs-number">3</span><span class="hljs-number">2</span>  # 算法：crc<span class="hljs-number">1</span><span class="hljs-number">6</span>(default) and crc<span class="hljs-number">3</span><span class="hljs-number">2</span>\n  rep: hex    # 进制：dec(default) and hex<span class="hljs-number">1</span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span><span class="hljs-number">5</span><span class="hljs-number">6</span>\n\n</code></pre>\n<p>这里将页面都添加了 .html 的后缀，用来伪装成静态页面(虽说Hexo的页面本身就是静态页面)，这样可以直接从路径就知道这是个静态页面，方便seo。</p>\n<p>接下来重新部署三连，可以看到我们的文章路径变成了 /2018/xxxxx.html，接下来就算我们将文字标题命名为中文也没问题了。</p>\n</section>\n'},305:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: VSCode之git插件显示当前commit信息,\ncategories: 技术,\npath: /archives,\ncomments: true,\ndate: 2019-06-14 14:31:04,\ntags: ,\nkeywords: ,\ndescription: ,\nphotos: microsoft\n</header>\n---\n<h3>GitLens — Git supercharged</h3>\n<p>开发过程中难免会遇到以下几种情况：</p>\n<ol>\n<li>自己的辛辛苦苦CV 过来的代码没了。你能会怀疑长时间使用CV 难道是CV按键不好使了。</li>\n<li>自己写的业务逻辑怎么多几个flag。整个人都在思考这个flag到底有没有用，能不能删。</li>\n<li>遇到有问题的代码，不知道谁最后修改的</li>\n</ol>\n<h3>安装完 GitLens 立马逆袭</h3>\n<p>它能显示每一行的commit的信息包括作者、修改时间、哪次提交的commit\n让你直接找到\'肇事者\'缉拿归案</p>\n<h3>安装</h3>\n<p>安装很简单打开vscode 点击左边的扩展\nwindow按下 <code>ctrl + shift + x</code>,\nmac 按下 <code>shift + command + x</code>;\n点击安装 安装好后重新加载！</p>\n<p><img src="https://cdn.jsdelivr.net/gh/qiang520184/cdn@1.4.4/images/vscode/gitLens.png" alt=""></p>\n</section>\n'},306:function(n,l,t){"use strict";t.r(l),l.default="<section><hr>\n<header>\ntitle: git知多少,\ncategories: 技术,\npath: /archives,\ncomments: true,\ndate: 2019-05-29 18:02:54,\ntags: ,\nkeywords: ,\ndescription: ,\nphotos: git\n</header>\n---\n<h2>git</h2>\n<p>git使用之前是需要安装的</p>\n<h3>git的安装</h3>\n<ol>\n<li>windows 安装<a href=\"http://git-scm.com/download\">点击这里</a>直接下载安装器。下载完成一路next.... ok齐活了。</li>\n<li>mac 安装git比较有意思。macOS系统有一个小彩蛋。command + 空格。搜索终端并打开终端，直接输入 git init 然后轻击一下回车。一点也不神奇的东西出来了\n系统就会给你弹出一个git 安装器。还是一样的next。你的mac就获得了git 全部属性加持。勇士去战斗吧。</li>\n</ol>\n<h3>创建版本库</h3>\n<p>git init   #初始化本地版本库\ngit init 完之后会生成一个.git 的文件。如果你看不见.git后缀的文件，请你先擦亮你的眼睛和眼镜。</p>\n<ol>\n<li>mac 按下 shift + command + .  就能看到电脑的隐藏文件了。有私密信息的同志请在按一下隐藏起来，以免有损你的形象。</li>\n<li>windows 呵呵了 windows好吧 显示隐藏文件有很多\n<ol>\n<li>XP系统  先打开 '我的电脑' 窗口上方有一个'工具' 工具里面有个 '文件夹选项' &gt; '查看' &gt; '隐藏文件和文件夹' 最后点击一下 '应用到所有文件夹'</li>\n<li>win7系统  打开 '我的电脑' '组织' &gt; '文件夹和搜索选项' &gt; '查看' &gt; '隐藏文件和文件夹' 最后点击一下 '应用到所有文件夹'</li>\n<li>win10系统 打开 '此电脑‘ &gt; '查看' &gt; 点一下 '平铺'  就能查看到 '隐藏文件和文件夹'了</li>\n</ol>\n</li>\n</ol>\n<p>git clone url 克隆远程版本库</p>\n<h3>修改和提交</h3>\n<ol>\n<li>git status   查看状态</li>\n<li>git diff     查看变更内容</li>\n<li>git add .    跟踪所有改动过的文件</li>\n<li>git add 'file' 跟踪指定的文件</li>\n<li>git mv 'old' 'new' 文件改名</li>\n<li>git rm 'file' 删除文件</li>\n<li>git rm --cached 'file'  停止跟踪文件但不删除</li>\n<li>git commit -m 'message' 提交所有更新过的文件</li>\n<li>git commit --amend 修改最后一次提交</li>\n</ol>\n<h3>查看提交历史</h3>\n<ol>\n<li>git log  查看提交历史</li>\n<li>git log -p 'file' 查看指定文件的提交历史</li>\n<li>git blame 'file'  以列表方式查看指定文件的提交历史</li>\n</ol>\n<h3>撤销</h3>\n<ol>\n<li>git reset --hard HEAD 撤销工作目录中所有未提交文件的修改内容</li>\n<li>git checkout HEAD 'file' 撤销指定的为提交文件的修改内容</li>\n<li>git revert <code>&lt;commit&gt;</code>  撤销指定的提交</li>\n</ol>\n<h3>分支与标签</h3>\n<ol>\n<li>git branch  显示所有本地分支</li>\n<li>git checkout <code>&lt;branch/tag&gt;</code>  切换到指定分支或标签</li>\n<li>git branch  <code>&lt;new-branch&gt;</code>   创建新分支</li>\n<li>git branch  -d <code>&lt;branch&gt;</code>    删除本地分支</li>\n<li>git tag    列出所有本地标签</li>\n<li>git tag <code>&lt;tag name&gt;</code>  基于最新提交创建标签</li>\n<li>git tag -d <code>&lt;tag name&gt;</code>  删除标签</li>\n</ol>\n<h3>合并与衍合</h3>\n<ol>\n<li>git merge <code>&lt;branch&gt;</code>  合并指定分支到当前分支</li>\n<li>git rebase <code>&lt;branch&gt;</code>  衍合指定分支到当前分支</li>\n</ol>\n<h3>远程操作</h3>\n<ol>\n<li>git remote -v   查看远程版本库信息</li>\n<li>git remote show <code>&lt;remote&gt;</code> 查看指定远程版本库信息</li>\n<li>git remote add <code>&lt;remote&gt;</code> <code>&lt;url&gt;</code> 添加远程版本库</li>\n<li>git fetch <code>&lt;remote&gt;</code>  从远程库获取代码</li>\n<li>git pull <code>&lt;remote&gt;</code> <code>&lt;branch&gt;</code> 下载代码及快速合并</li>\n<li>git push <code>&lt;remote&gt;</code> <code>&lt;branch&gt;</code> 上传代码及快速合并</li>\n<li>git push <code>&lt;remote&gt;</code> :<code>&lt;branch/tag-name&gt;</code> 删除远程分支或标签</li>\n<li>git push --tags 上传所有标签</li>\n</ol>\n</section>\n"},307:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: js中全等和等于,\ncategories: 技术,\npath: /archives,\ncomments: true,\ndate: 2019-06-17 11:51:32,\ntags: ,\nkeywords: ,\ndescription: ,\nphotos: javascript\n</header>\n---\n<h3>js中的比较等于和全等</h3>\n<h3>一、=一个等于号</h3>\n<pre><code class="language-js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;\n<span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;\n<span class="hljs-built_in">console</span>.log(a, b); <span class="hljs-comment">// 1  2</span>\n<span class="hljs-built_in">console</span>.log(b = a);  <span class="hljs-comment">// 1</span>\n</code></pre>\n<p>js中一个等于号是一个赋值的过程 console.log(b=a) 怎么等与1呢 console.log的括号中 打印的是执行后的结果所以是1</p>\n<h3>二、==两个等于号</h3>\n<pre><code class="language-js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;\n<span class="hljs-keyword">var</span> b = <span class="hljs-string">\'1\'</span>;\n<span class="hljs-built_in">console</span>.log(a == b); <span class="hljs-comment">//true</span>\n\n<span class="hljs-keyword">var</span> obj = {};\n<span class="hljs-keyword">var</span> obj1 = {};\n<span class="hljs-built_in">console</span>.log(obj == obj1); <span class="hljs-comment">// false</span>\n\n<span class="hljs-built_in">console</span>.log([] == []); <span class="hljs-comment">// false</span>\n<span class="hljs-built_in">console</span>.log([] == ![]); <span class="hljs-comment">// true</span>\n\n<span class="hljs-built_in">console</span>.log({} == {}); <span class="hljs-comment">//false</span>\n<span class="hljs-built_in">console</span>.log({} == !{}); <span class="hljs-comment">//false</span>\n\n<span class="hljs-built_in">console</span>.log(+<span class="hljs-string">\'1\'</span> == <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span>\n<span class="hljs-built_in">console</span>.log(-<span class="hljs-string">\'1\'</span> == <span class="hljs-literal">true</span>)  <span class="hljs-comment">// false</span>\n<span class="hljs-built_in">console</span>.log(-<span class="hljs-string">\'1\'</span> == <span class="hljs-literal">false</span>) <span class="hljs-comment">// false</span>\n\n</code></pre>\n<h3>三、===三个等于号</h3>\n<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {};\n<span class="hljs-keyword">var</span> obj1 = {};\n<span class="hljs-built_in">console</span>.log(obj === obj1); <span class="hljs-comment">// false</span>\n\n<span class="hljs-keyword">var</span> a = {};\n<span class="hljs-keyword">var</span> b = a;\n<span class="hljs-built_in">console</span>.log(a === b); <span class="hljs-comment">// true;</span>\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>)</span>{}\n<span class="hljs-keyword">var</span> p1=  <span class="hljs-keyword">new</span> fn1();\n<span class="hljs-keyword">var</span> p2=  <span class="hljs-keyword">new</span> fn1();\n<span class="hljs-built_in">console</span>.log(p1, p2);\n<span class="hljs-built_in">console</span>.log(p1 === p2); <span class="hljs-comment">// false;</span>\n\n\n<span class="hljs-built_in">console</span>.log([] === []); <span class="hljs-comment">// false</span>\n<span class="hljs-built_in">console</span>.log([] === ![]); <span class="hljs-comment">// false</span>\n\n<span class="hljs-built_in">console</span>.log({} === !{}); <span class="hljs-comment">// false</span>\n<span class="hljs-built_in">console</span>.log(-<span class="hljs-string">\'1\'</span> === <span class="hljs-number">1</span>); <span class="hljs-comment">// false</span>\n<span class="hljs-built_in">console</span>.log(+<span class="hljs-string">\'1\'</span> === <span class="hljs-number">1</span>); <span class="hljs-comment">// true;</span>\n</code></pre>\n</section>\n'},308:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: js基本数据类型和引用数据类型的区别,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: javascript,\ndate: 2019-05-07 10:45:12,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<h2>栈（stack）和堆（heap）</h2>\n<pre><code>stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小也不一定会自动释放\n</code></pre>\n<h2>js分为基本数据类型和引用数据类型</h2>\n<pre><code>基本数据类型指的是简单的数据段,数据大小确实，内存空间大小可以分配，他们是直接按值存放的，所以可以直接`按值访问`\n引用数据类型指的是有多个值构成的对象。\n当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型还是引用数据类型。\n</code></pre>\n<h3>基本数据类型(放在栈中）</h3>\n<pre><code>Number、 String、Boolean、Null、Undefined、Symbol（ES6） 基本数据类型是按值访问的。因为可以直接操作保存在变量中的实际值。\n</code></pre>\n<pre><code class="language-js">    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;\n    <span class="hljs-keyword">var</span> b = a;\n    b = <span class="hljs-number">20</span>;\n    <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//10</span>\n    <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">//20</span>\n</code></pre>\n<p>基本数据类型是对值的重新赋值，b先被赋值上了a的值10，b又被重新赋值为20。此时b的值为20，a没有被重新赋值，所以a 还是10</p>\n<h3>引用数据类型(存放在堆内存中的对象，每个空间大小不一样，要根据情况进行特定的配置)</h3>\n<pre><code>Object、Array、Function、Data 等\n</code></pre>\n<p><font color=\'red\'>js的引用数据类型是保存在堆内存的对象</font>\n<font color=\'red\'>与其他语言的不同是，你不可以直接访问堆内存空间中的位置和堆内存空间。只能操作对象在栈内存中的引用地址。</font>\n所以，引用数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存在堆内存中的对象。</p>\n<pre><code class="language-js">    <span class="hljs-keyword">var</span> obj1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();\n    <span class="hljs-keyword">var</span> obj2 = obj1;\n    obj2.name = <span class="hljs-string">"haha"</span>;\n    <span class="hljs-built_in">console</span>.log(obj1.name) <span class="hljs-comment">//haha</span>\n</code></pre>\n<p>这说明两个引用数据类型指向了同一个堆内存对象。obj1赋值给了obj2，实际上这个堆内存对象在栈内存堆引用地址复制了一份给了obj2,实际上他们共同指向了同一个堆内存对象。所以给obj2的某一个属性修改或赋值是obj1的属性也跟着一起改变了</p>\n<h3>基本类型和引用类型区别</h3>\n<ol>\n<li>声明变量时内存分配不同\n<ol>\n<li>基本类型： 存在栈中，因为占据空间是固定的，可以将他们存在较小的内存中-栈中，这样便于快速查询变量的值</li>\n<li>引用类型： 存在堆中，栈中储存的变量，只是用来查找堆中堆引用地址。\n这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查找速度。相反，放在变量的栈内存中的值是该对象存储在堆内存中堆地址。地址的大小是固定的，所以把它存储在栈内存中的变量性能无任何负面影响</li>\n</ol>\n</li>\n<li>不同的内存分配带来不同的访问机制\n在javascript中不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后在按照这个地址去获得这个对象中的值，这就是<code>按引用访问</code>。 而基本类型的值则是可以直接访问到到。</li>\n<li>复制变量时的不同\n<ol>\n<li>基本类型：在将一个保存着原始值的变量复制给另一个变量时，会将基本类型值赋值给新变量，此后两个变量是完全独立的，他们只是值相同而已</li>\n<li>引用类型：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个变量保存在的栈内存地址赋值给新的变量。此时两个变量都指向了在堆内存中的同一个对象，它们中任何一个做出改变都会影响到另一个变量。（复制对象值不过是把栈内存中的指针复制了一个）</li>\n</ol>\n</li>\n<li>参数传递的不同（把实参复制给形参的过程）\n<ol>\n<li>基本类型： 只是把变量里的值传递给实参，之后参数和变量互不影响</li>\n<li>引用类型： 对象变量它里面的值是这个对象在堆内存中的内存地址，因此它传递的值也就是这个内存地址，这就是为什么函数内部修改了这个参数，函数外部这个对象也修改了，因为它们访问的是 同一个内存地址</li>\n</ol>\n</li>\n</ol>\n<p>看一下代码吧</p>\n<pre><code class="language-js">        <span class="hljs-comment">//基本类型</span>\n        <span class="hljs-keyword">var</span> a = <span class="hljs-number">12</span>;\n        <span class="hljs-built_in">console</span>.log(a, <span class="hljs-string">"a"</span>)  <span class="hljs-comment">//12</span>\n        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x</span>) </span>{\n            x++;\n            <span class="hljs-built_in">console</span>.log(x, <span class="hljs-string">"fn"</span>) <span class="hljs-comment">//13</span>\n        }\n        fn(a)\n        <span class="hljs-built_in">console</span>.log(a, <span class="hljs-string">"a"</span>) <span class="hljs-comment">//12</span>\n\n\n        <span class="hljs-comment">//引用类型</span>\n        <span class="hljs-keyword">var</span> obj = {\n            <span class="hljs-attr">a</span>: <span class="hljs-number">12</span>,\n            <span class="hljs-attr">b</span>: <span class="hljs-string">"b"</span>\n        }\n        <span class="hljs-built_in">console</span>.log(obj, <span class="hljs-string">"obj"</span>) <span class="hljs-comment">//{a: 12, b: "b"}</span>\n        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">obj</span>) </span>{\n            obj.a++;\n            <span class="hljs-built_in">console</span>.log(obj, <span class="hljs-string">"fn2"</span>) <span class="hljs-comment">//{a: 13, b: "b"}</span>\n        }\n        fn2(obj)\n        <span class="hljs-built_in">console</span>.log(obj, <span class="hljs-string">"obj"</span>) <span class="hljs-comment">//{a: 13, b: "b"}</span>\n\n</code></pre>\n</section>\n'},309:function(n,l,t){"use strict";t.r(l),l.default="<section><hr>\n<header>\ntitle: js常用正则验证,\ncategories: 技术,\npath: /archives,\ncomments: true,\ndate: 2019-06-13 18:05:54,\ntags: ,\nkeywords: ,\ndescription: ,\nphotos: javascript\n</header>\n---\n</section>\n"},310:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: js数组去重,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: javascript,\ndate: 2018-10-08 20:03:06,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<h5>set去重</h5>\n<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">"c"</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"b"</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"a"</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]\n  <span class="hljs-keyword">var</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr)\n  <span class="hljs-built_in">console</span>.log([...newSet])\n\n</code></pre>\n<h5>Array.prototype.includes()</h5>\n<pre><code class="language-js">    <span class="hljs-keyword">var</span> newArr = []\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">of</span> arr) {\n      <span class="hljs-keyword">if</span> (!newArr.includes(i)) {\n        newArr.push(i)\n      }\n    }\n    <span class="hljs-built_in">console</span>.log(newArr)\n</code></pre>\n<h5>相邻元素去重</h5>\n<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]\n<span class="hljs-keyword">var</span> ar = arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {\n      <span class="hljs-keyword">return</span> a - b;\n    })\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ar.length; i++) {\n      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; ar.length; j++) {\n        <span class="hljs-keyword">if</span> (ar[i] == ar[j + <span class="hljs-number">1</span>]) {\n          ar.splice(i, <span class="hljs-number">1</span>)\n        }\n      }\n    }\n    <span class="hljs-built_in">console</span>.log(ar)\n</code></pre>\n<h5>Array.prototype.reduce()</h5>\n<pre><code class="language-js">  <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">"c"</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"b"</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"a"</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]\n  init = []\n    <span class="hljs-keyword">var</span> result = arr.sort().reduce(<span class="hljs-function">(<span class="hljs-params">init, current</span>) =&gt;</span> {\n      <span class="hljs-built_in">console</span>.log(init, current)\n      <span class="hljs-keyword">if</span> (init.length === <span class="hljs-number">0</span> || init[init.length - <span class="hljs-number">1</span>] !== current) {\n        init.push(current);\n      }\n      <span class="hljs-keyword">return</span> init;\n    }, []);\n    <span class="hljs-built_in">console</span>.log(result)\n\n</code></pre>\n<h5>对象去重</h5>\n<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">"c"</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"b"</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"a"</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]\n <span class="hljs-keyword">var</span> obj = {}\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">of</span> arr) {\n      <span class="hljs-built_in">console</span>.log(i)\n      obj[i] = i\n    }\n    <span class="hljs-keyword">var</span> brr = <span class="hljs-built_in">Object</span>.values(obj)\n    <span class="hljs-built_in">console</span>.log(brr)\n</code></pre>\n<h5>filter 去重</h5>\n<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">"c"</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"b"</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"a"</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]\n <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{\n\n      <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function">(<span class="hljs-params">item, index, brr</span>) =&gt;</span> {\n        <span class="hljs-keyword">return</span> brr.indexOf(item) === index\n      })\n    }\n    <span class="hljs-built_in">console</span>.log(unique(arr))\n</code></pre>\n</section>\n'},311:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: js数组排序,\ncategories: 技术,\npath: /archives,\ncomments: true,\ndate: 2019-06-02 13:33:37,\ntags: ,\nkeywords: ,\ndescription: ,\nphotos: javascript\n</header>\n---\n<h3><font color="red">sort排序</font></h3>\n<pre><code class="language-js">    <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>];\n    <span class="hljs-keyword">let</span> brr = arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {\n        <span class="hljs-keyword">return</span> a - b;\n    })\n    <span class="hljs-built_in">console</span>.log(brr);\n\n    <span class="hljs-comment">// let arr = [1,2,4,6,9,4,2,4];</span>\n    <span class="hljs-comment">// let brr = arr.sort();</span>\n    <span class="hljs-comment">// console.log(brr);</span>\n</code></pre>\n<h3><font color="red">水桶排序</font></h3>\n<pre><code class="language-js">    <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">19</span>,<span class="hljs-number">8</span>,<span class="hljs-number">47</span>,<span class="hljs-number">34</span>,<span class="hljs-number">78</span>,<span class="hljs-number">95</span>,<span class="hljs-number">64</span>,<span class="hljs-number">22</span>,<span class="hljs-number">50</span>,<span class="hljs-number">88</span>];\n    <span class="hljs-keyword">var</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">false</span>,arr); <span class="hljs-comment">//找出arr数组中的最大值</span>\n    <span class="hljs-keyword">var</span> brr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max);  <span class="hljs-comment">//创建水桶数组</span>\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i&lt;arr.length;i++){\n      brr[arr[i]] = arr[i];\n    }\n    brr = <span class="hljs-built_in">Object</span>.values(brr);\n    <span class="hljs-built_in">console</span>.log(brr);\n</code></pre>\n<h3><font color="red">冒泡排序</font></h3>\n<pre><code class="language-js">    <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">19</span>,<span class="hljs-number">8</span>,<span class="hljs-number">47</span>,<span class="hljs-number">34</span>,<span class="hljs-number">78</span>,<span class="hljs-number">95</span>,<span class="hljs-number">64</span>,<span class="hljs-number">22</span>,<span class="hljs-number">50</span>,<span class="hljs-number">88</span>];\n    <span class="hljs-keyword">var</span> len = arr.length, num;\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {\n        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len - (i + <span class="hljs-number">1</span>); j++) {\n            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) {\n                <span class="hljs-keyword">var</span> num = arr[j];\n                arr[j] = arr[j + <span class="hljs-number">1</span>];\n                arr[j + <span class="hljs-number">1</span>] = num;\n           }\n\n       }\n   }\n   <span class="hljs-built_in">console</span>.log(arr);\n</code></pre>\n<h3><font color="red">时间排序</font></h3>\n<p>一切都交给时间，时间会给你答案。<code>谨慎使用!!!</code></p>\n<pre><code class="language-js">    <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">19</span>,<span class="hljs-number">8</span>,<span class="hljs-number">47</span>,<span class="hljs-number">34</span>,<span class="hljs-number">78</span>,<span class="hljs-number">95</span>,<span class="hljs-number">64</span>,<span class="hljs-number">22</span>,<span class="hljs-number">50</span>,<span class="hljs-number">88</span>];\n    <span class="hljs-keyword">var</span> brr = [];\n    arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {\n        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{\n            brr.push(item)\n        },item*<span class="hljs-number">100</span>)\n    })    \n</code></pre>\n</section>\n'},312:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: js日期格式化,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: javascript,\ndate: 2019-04-17 00:08:58,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<pre><code class="language-js">\n        <span class="hljs-keyword">var</span> arr =[<span class="hljs-string">"2018-01-0212:17:00"</span>,<span class="hljs-string">"2016/05/0112:00"</span>,<span class="hljs-string">"2018-01-0512:29:00"</span>,\n        <span class="hljs-string">"2019010112"</span>,<span class="hljs-string">"2016/09/0113:00:00"</span>,<span class="hljs-string">"20180521185621"</span>,<span class="hljs-string">"2019/04/09 12:00:00"</span>,\n        <span class="hljs-string">"2017-01-0512:45:11"</span>,<span class="hljs-string">"2019020111"</span>,<span class="hljs-string">"2018/05/0112:00:00"</span>,<span class="hljs-string">"2018010113"</span>,\n        <span class="hljs-string">"2019-02-02 12:00:00"</span>,<span class="hljs-string">"20181020120000"</span>];\n        \n      \n        <span class="hljs-keyword">var</span> opt = <span class="hljs-string">"YYYY-MM-dd HH:MM:SS"</span>\n        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myReplace</span>(<span class="hljs-params">str,reg,newStr</span>)</span>{\n            <span class="hljs-keyword">return</span> str.replace(reg,newStr)\n        }\n\n        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mySlice</span>(<span class="hljs-params">str,start,end</span>)</span>{\n            <span class="hljs-keyword">return</span> str.slice(start,end)\n        }\n\n        <span class="hljs-keyword">var</span> brr = []\n        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++){\n           <span class="hljs-built_in">console</span>.log(arr[i])\n           <span class="hljs-keyword">var</span> c = mySlice(arr[i],<span class="hljs-number">0</span>,<span class="hljs-number">4</span>)\n           <span class="hljs-keyword">var</span> b = myReplace(arr[i],/^\\d{<span class="hljs-number">4</span>}\\D?<span class="hljs-regexp">/,"") /</span><span class="hljs-regexp">/arr[i].replace(/</span>^\\d{<span class="hljs-number">4</span>}\\D?<span class="hljs-regexp">/,"") \n           var d = mySlice(b,0,2) /</span><span class="hljs-regexp">/b.slice(0,2)\n           var e = myReplace(b,/</span>^\\d{<span class="hljs-number">2</span>}\\D?<span class="hljs-regexp">/,"") /</span><span class="hljs-regexp">/b.replace(/</span>^\\d{<span class="hljs-number">2</span>}\\D?<span class="hljs-regexp">/,"")\n           var f = mySlice(e,0,2) /</span><span class="hljs-regexp">/e.slice(0,2)\n           var g = myReplace(e,/</span>^\\d{<span class="hljs-number">2</span>}\\D?<span class="hljs-regexp">/,"") /</span><span class="hljs-regexp">/e.replace(/</span>^\\d{<span class="hljs-number">2</span>}\\D?<span class="hljs-regexp">/,"")\n           var h = mySlice(g,0,2) /</span><span class="hljs-regexp">/g.slice(0,2)\n           var j = myReplace(g,/</span>^\\d{<span class="hljs-number">2</span>}\\D?<span class="hljs-regexp">/,"") /</span><span class="hljs-regexp">/g.replace(/</span>^\\d{<span class="hljs-number">2</span>}\\D?<span class="hljs-regexp">/,"")\n           var k = mySlice(j,0,2)   /</span><span class="hljs-regexp">/j.slice(0,2)\n           if(k == ""){\n                k = "00"\n            }\n           var l = myReplace(j,/</span>^\\d{<span class="hljs-number">2</span>}\\D?<span class="hljs-regexp">/,"") /</span><span class="hljs-regexp">/j.replace(/</span>^\\d{<span class="hljs-number">2</span>}\\D?<span class="hljs-regexp">/,"")\n \n            if(l == ""){\n                l = "00"\n            }\n           brr[i] = c + "-" + d + "-" + f +"  "+ h + ":" + k + ":"+ l \n        }\n        console.log(brr)\n\n</span></code></pre>\n</section>\n'},313:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: js深浅拷贝,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: javascript,\ndate: 2019-04-16 11:57:16,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<h2>扩展运算符</h2>\n<pre><code class="language-js">    <span class="hljs-keyword">var</span> obj = {\n        <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,\n        <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>\n    }\n    <span class="hljs-keyword">var</span> copyObj = obj\n    obj.a = <span class="hljs-number">222</span>\n    <span class="hljs-built_in">console</span>.log(obj) <span class="hljs-comment">//{a: 222, b: 2}</span>\n    <span class="hljs-built_in">console</span>.log(copyObj) <span class="hljs-comment">//{a: 222, b: 2}</span>\n\n</code></pre>\n<p>浅拷贝：拷贝目标被修改，拷贝出来的变量也会改变，浅拷贝只是对其内存地址对引用。</p>\n<p>深拷贝：拷贝目标被修改，拷贝出来的变量是不受影响的</p>\n<p>1.扩展运算符深拷贝</p>\n<pre><code class="language-js">    <span class="hljs-keyword">var</span> obj = {\n        <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,\n        <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>\n    }\n    <span class="hljs-keyword">var</span> copyObj = {...obj}\n    obj.a = <span class="hljs-number">222</span>\n    <span class="hljs-built_in">console</span>.log(obj) <span class="hljs-comment">//{a: 222, b: 2}</span>\n    <span class="hljs-built_in">console</span>.log(copyObj) <span class="hljs-comment">//{a: 1, b: 2}</span>\n\n    <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]\n    <span class="hljs-keyword">var</span> copyArr = [...arr]\n    <span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">0</span>] = <span class="hljs-string">"123"</span>)\n    <span class="hljs-built_in">console</span>.log(arr)  <span class="hljs-comment">//["123", 2, 4, 6]</span>\n    <span class="hljs-built_in">console</span>.log(copyArr) <span class="hljs-comment">//[1, 2, 4, 6]</span>\n\n\n</code></pre>\n<ol>\n<li>Object.assgin()深拷贝</li>\n</ol>\n<pre><code class="language-js">\n</code></pre>\n<pre><code class="language-js"></code></pre>\n<pre><code class="language-js"></code></pre>\n</section>\n'},314:function(n,l,t){"use strict";t.r(l),l.default="<section><hr>\n<header>\ntitle: js闭包,\ncategories: 技术,\npath: /archives,\ncomments: true,\ndate: 2019-06-21 16:43:17,\ntags: ,\nkeywords: ,\ndescription: ,\nphotos: javascript\n</header>\n---\n<h3>闭包</h3>\n<p>MDN是这样说点 <code>A closure is the combination of a function and the lexical environment within which that function was declared</code>,\n翻译过来是 闭包是函数和声明该函数的词法环境的组合。</p>\n</section>\n"},315:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: vue.filter自定义过滤器,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: vue,\ndate: 2019-06-08 15:10:03,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<h3>vue过滤器</h3>\n<p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</p>\n<pre><code class="language-js">    &lt;!-- 在双花括号中 --&gt;\n    <span>{{</span> message | filterName <span>}}</span>\n\n    &lt;!-- 在 <span class="hljs-string">`v-bind`</span> 中 --&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">"rawId | filterFormatId"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n</code></pre>\n<h4>一、全局过滤器</h4>\n<p>全局过滤器在vue实力之前，在vue根实力上注册</p>\n<pre><code class="language-js">&lt;!-- main.js--&gt;\nVue.filter(<span class="hljs-string">\'formatMsg\'</span>, (value) =&gt; {\n    <span class="hljs-keyword">if</span> (!value) {\n        <span class="hljs-keyword">return</span>;\n    }\n    <span class="hljs-keyword">return</span> value.replace(<span class="hljs-string">\'高大上\'</span>, <span class="hljs-string">\'辣鸡\'</span>);\n});\n<span class="xml"><span class="hljs-comment">&lt;!-- About.vue --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"about"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span>{{</span>msg | formatMsg<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">\'About\'</span>,\n    data() {\n        <span class="hljs-keyword">return</span> {\n            <span class="hljs-attr">msg</span>: <span class="hljs-string">\'About页的高大上过滤器\'</span>\n        };\n    }\n};\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</span></code></pre>\n<h4>二、组件过滤器</h4>\n<p>组件过滤器就是在当前组件生效的过滤器</p>\n<pre><code class="language-js">&lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span>{{</span>msg<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span>{{</span>msg | formatMsg<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    data() {\n        <span class="hljs-keyword">return</span> {\n            <span class="hljs-attr">msg</span>: <span class="hljs-string">\'Home页的高大上过滤器\'</span>\n        };\n    },\n    <span class="hljs-attr">filters</span>: {\n        <span class="hljs-attr">filterName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{\n            <span class="hljs-keyword">if</span> (!value) {\n                <span class="hljs-keyword">return</span>;\n            }\n            <span class="hljs-keyword">return</span> value.replace(<span class="hljs-string">\'高大上\'</span>, <span class="hljs-string">\'辣鸡组件\'</span>);\n        }\n    }\n}\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>\n</code></pre>\n<p><img src="https://cdn.jsdelivr.net/gh/qiang520184/cdn@1.4.3/images/vue/1.png" alt="photos"></p>\n<p>组件、全局相同名称的过滤器，组件过滤器优先级高</p>\n<h4>三、过滤器传参</h4>\n<pre><code class="language-js">&lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"about"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>About页<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span>{{</span>msg | formatMsg(params1, params2)<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-my-html</span>&gt;</span><span>{{</span>msg | formatMsg(params1, params2)<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    data() {\n        <span class="hljs-keyword">return</span> {\n            <span class="hljs-attr">msg</span>: <span class="hljs-string">\'About页的高大上过滤器\'</span>,\n            <span class="hljs-attr">params1</span>: <span class="hljs-string">\'高大上\'</span>,\n            <span class="hljs-attr">params2</span>: <span class="hljs-string">\'辣鸡组件\'</span>\n        };\n    },\n    <span class="hljs-attr">directives</span>: {\n        <span class="hljs-attr">myHtml</span>: {\n            inserted(el) {\n                <span class="hljs-keyword">let</span> left = <span class="hljs-regexp">/&amp;lt;/g</span>;\n                <span class="hljs-keyword">let</span> right = <span class="hljs-regexp">/&amp;gt;/g</span>;\n                <span class="hljs-keyword">let</span> htmlStr = el.innerHTML.replace(left, <span class="hljs-string">\'&lt;\'</span>).replace(right, <span class="hljs-string">\'&gt;\'</span>);\n                el.innerHTML = htmlStr;\n            }\n        }\n    },\n    <span class="hljs-attr">filters</span>: {\n        formatMsg(value, params1, params2) {\n            <span class="hljs-keyword">if</span> (!value) {\n                <span class="hljs-keyword">return</span>;\n            }\n            <span class="hljs-keyword">return</span> value.replace(params1, <span class="hljs-string">`&lt;span style=color:red;&gt;<span class="hljs-subst">${params2}</span>&lt;/span&gt;`</span>);\n        }\n    }\n};\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>\n</code></pre>\n<p><code>formatMsg(params1, params2)</code>传参在括号里面传参，管道符前面的变量是过滤器的默认参数,也是第一个参数,\n<img src="https://cdn.jsdelivr.net/gh/qiang520184/cdn@1.4.3/images/vue/2.png" alt="photos">\n过滤器<code>params2</code>参数,拼接了一个span标签但是在vue编译的时候没有把它变成我们想要的span标签。这个时候我们可以结合\n<a href="https://www.fudaqiang.com/vue自定义指令.html" target="blank"><font color="red">vue自定义指令</font></a>对当前标签内的内容，进行进一步编译。达到我们最终想要的结果。</p>\n</section>\n'},316:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: vue.sync修饰符,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: vue,\ndate: 2019-05-28 15:49:14,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<p>一个小demo 父组件通过 isShow 来控制子组件的显示隐藏</p>\n<pre><code class="language-js">&lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>\n               <span class="hljs-attr">value</span>=<span class="hljs-string">"我是父组件中的按钮"</span>\n               @<span class="hljs-attr">click</span>=<span class="hljs-string">"show"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">child</span> @<span class="hljs-attr">is-show</span>=<span class="hljs-string">"childIsShow"</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"isShow"</span>/&gt;</span> \n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n    <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">\'./child\'</span>;\n    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n        data() {\n            <span class="hljs-keyword">return</span> {\n                <span class="hljs-attr">isShow</span>: <span class="hljs-literal">false</span>\n            };\n        },\n        <span class="hljs-attr">components</span>: {\n            child\n        },\n        <span class="hljs-attr">methods</span>: {\n            show() {\n                <span class="hljs-keyword">this</span>.isShow = <span class="hljs-literal">true</span>;\n            },\n            childIsShow(val) {\n                <span class="hljs-keyword">this</span>.isShow = val;\n            }\n        }\n    };\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</span></code></pre>\n<pre><code class="language-js">    &lt;div&gt;\n        我是一个子组件！\n        &lt;input type=<span class="hljs-string">"button"</span> value=<span class="hljs-string">"点我隐身"</span> @click=<span class="hljs-string">"upIsShow"</span>&gt;\n    <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n        <span class="hljs-attr">methods</span>: {\n            upIsShow() {\n                <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">\'is-show\'</span>, <span class="hljs-literal">false</span>);\n            }\n        }\n    };\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>\n</code></pre>\n<p>子组件向父组件派发一个事件,父组件监听子组件派发的事件获取到内容修改 isShow, 达到显示隐藏</p>\n<pre><code class="language-js">&lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>\n               <span class="hljs-attr">value</span>=<span class="hljs-string">"我是父组件中的按钮"</span>\n               @<span class="hljs-attr">click</span>=<span class="hljs-string">"show"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:is-show.sync</span>=<span class="hljs-string">"isShow"</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"isShow"</span>/&gt;</span> \n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n    <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">\'./child\'</span>;\n    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n        data() {\n            <span class="hljs-keyword">return</span> {\n                <span class="hljs-attr">isShow</span>: <span class="hljs-literal">false</span>\n            };\n        },\n        <span class="hljs-attr">components</span>: {\n            child\n        },\n        <span class="hljs-attr">methods</span>: {\n            show() {\n                <span class="hljs-keyword">this</span>.isShow = <span class="hljs-literal">true</span>;\n            }\n        }\n    };\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</span></code></pre>\n<p>父组件监听子组件的时候多加了一个修饰符.sync</p>\n<p>.sync 其实是一个缩写 @update:isShow=&quot;val=&gt;isShow=val&quot;语法糖。</p>\n<pre><code class="language-js">&lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n        我是一个子组件！\n        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"点我隐身"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"upIsShow"</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n        <span class="hljs-attr">methods</span>: {\n            upIsShow() {\n                <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">\'update:is-show\'</span>, <span class="hljs-literal">false</span>);\n            }\n        }\n    };\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>\n</code></pre>\n<p>子组件派发的事件前面多了一个<code>update:</code></p>\n</section>\n'},317:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: vue中将html字符串转换成html遇到的小问题,\ncategories: 技术,\npath: /archives,\ncomments: true,\ndate: 2019-05-24 20:14:55,\ntags: ,\nkeywords: ,\ndescription: ,\nphotos: vue\n</header>\n---\n<p>例子</p>\n<pre><code class="language-js">    &lt;template&gt;\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"suggestions"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"replay-dialog-list"</span>&gt;</span>\n            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item,index) in arr"</span>\n                <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>\n                <span class="hljs-attr">v-html</span>=<span class="hljs-string">"item"</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>\n    <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n    <span class="hljs-keyword">import</span> Axios <span class="hljs-keyword">from</span> <span class="hljs-string">\'axios\'</span>;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n        data() {\n            <span class="hljs-keyword">return</span> {\n                <span class="hljs-attr">arr</span>: []\n            };\n        },\n        <span class="hljs-attr">methods</span>: {\n            getData() {\n                Axios.get().then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n                    data &amp;&amp; data.length &amp;&amp; data.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {\n                            <span class="hljs-keyword">let</span> htmlStr = <span class="hljs-string">`&lt;div&gt;(<span class="hljs-subst">${item.keyword.replace(item.keyword, <span class="hljs-string">`&lt;span&gt;<span class="hljs-subst">${item.keyword}</span>&lt;/span&gt;`</span>)}</span>)&lt;/div&gt;\n                                    &lt;div&gt;<span class="hljs-subst">${item.departName}</span>&lt;/div&gt;`</span>;\n                            <span class="hljs-keyword">this</span>.arr.push({\n                                ...item,\n                                htmlStr\n                            });\n                        }\n                    });\n                });\n            }\n        }\n    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>\n</code></pre>\n</section>\n'},318:function(n,l,t){"use strict";t.r(l),l.default="<section><hr>\n<header>\ntitle: vue函数式组件,\ncategories: 技术,\npath: /archives,\ncomments: true,\ndate: 2019-06-06 10:19:03,\ntags: ,\nkeywords: ,\ndescription: ,\nphotos: vue\n</header>\n---\n</section>\n"},319:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: vue指令,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: vue,\ndate: 2019-04-08 22:16:33,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<h2>Vue 指令</h2>\n<h3>1、插值表达式</h3>\n<p>插值表达式就是以<strong>双重大括号</strong> ，类似 { <code>{msg}</code> }  的形式插入到 html 代码中。</p>\n<blockquote>\n<p>1、插值表达式还可以进行简单的运算（比如加减乘除等），但是不能完全放置js代码。</p>\n<p>2、插值表达式只能放在标签之间，而不能放在标签内部。</p>\n</blockquote>\n<h3>2、v-cloak</h3>\n<p>在 使用 {<code>{ msg }</code>} 的方式插入数据的时候，如果网速特别慢的话，  {<code>{ msg }</code> } 所代表的值不会立即显示出来，而会显示  {{ msg }} 这个字符串本身，怎么解决这个问题呢？</p>\n<p><strong>使用 v-cloak 和 CSS 表达式结合，能够解决插值表达式闪烁的问题，这样会在网络未加载完时，不显示字符串本身。</strong></p>\n<p>示例：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">\n  <span class="hljs-selector-attr">[v-cloak]</span> {\n    <span class="hljs-attribute">display</span>: none;\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n...\n<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-cloak</span>&gt;</span> {`{ msg }`} <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n</code></pre>\n<h3>3、v-text</h3>\n<p>默认 v-text 是没有闪烁问题的，但是 v-text 会覆盖元素中原本的内容，而 v-cloak 只会替换插值表达式，不会把 整个元素的内容清空。</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">"msg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n</code></pre>\n<h3>4、v-html</h3>\n<p><strong>v-text 知识插入的纯文本格式内容，而 v-html 可以插入为 html 标签的代码，并解析出来。</strong></p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">"msg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n...\ndata: {\n  msg: \'<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>哈哈，我是一个大大的H1， 我大，我骄傲<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\'\n},\n</code></pre>\n<h3>5、v-bind</h3>\n<p>v-bind 是 Vue中，提供的用于<strong>绑定属性</strong>的指令。<strong>将一个属性的值变成动态值。</strong></p>\n<blockquote>\n<p>注意： <code>v-bind:</code> 指令可以被简写为<code>:</code></p>\n</blockquote>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"按钮"</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"mytitle + \'123\'"</span>&gt;</span>\n...\ndata: {\n  mytitle: \'这是一个自己定义的title\'\n},\n</code></pre>\n<blockquote>\n<p>title 里面的内容就不是字符串了，而是会将 data 中的变量进行替换得到一个字符串整体。</p>\n</blockquote>\n<h3>6、v-on</h3>\n<p>v-on ：给某个元素绑定事件监听函数。注意，函数必须封装在methods内。</p>\n<blockquote>\n<p>注意：<code>v-on:</code> 指令可以被简写为<code>@</code></p>\n</blockquote>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"按钮"</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">"mytitle + \'123\'"</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"show"</span>&gt;</span>\n...\ndata: {\n  mytitle: \'这是一个自己定义的title\'\n},\nmethods: { // 这个 methods属性中定义了当前Vue实例所有可用的方法\n  show: function () {\n  \talert(\'Hello\')\n  }\n}\n</code></pre>\n<h3>7、v-model</h3>\n<p>v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V（即修改 data 的数据，自动同步到 html）， 无法实现数据的双向绑定。</p>\n<p>使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定（不仅可以修改 data 的数据，自动同步到 html，也可以修改 html 的代码，同步到 data 数据）。</p>\n<blockquote>\n<p>注意： <code>v-model</code> 只能运用在 表单元素中。</p>\n</blockquote>\n<h3>8、v-for</h3>\n<p>8.1、v-for 循环普通数组</p>\n<p>我们之前如果要循环赋值给 p 标签 data中 list=[1,2,3,4,5,6]; 数组的话，会这样写：</p>\n<pre><code class="language-html">\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span>{{</span>list[0]<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span>{{</span>list[1]<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span>{{</span>list[2]<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span>{{</span>list[3]<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span>{{</span>list[4]<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n \n    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">\n        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({\n            el: <span class="hljs-string">\'#app\'</span>,\n            data: {\n                list: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]\n            },\n            methods: {}\n        });\n    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n</code></pre>\n<p>这样的话，就会很繁琐。而 <code>v-for</code> 会提供循环遍历 list 数组来给 p 标签赋值。如下：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, i) in list"</span>&gt;</span>索引：<span>{{</span>i<span>}}</span> -- 项：<span>{{</span>item<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-comment">&lt;!-- 索引：0 -- 项：1\n               索引：1 -- 项：2\n               索引：2 -- 项：3\n               索引：3 -- 项：4\n               索引：4 -- 项：5\n               索引：5 -- 项：6 --&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n \n    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">\n        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({\n            el: <span class="hljs-string">\'#app\'</span>,\n            data: {\n                list: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]\n            },\n            methods: {}\n        });\n    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n</code></pre>\n<p>8.2、v-for 循环对象数组</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(user, i) in list"</span>&gt;</span>Id：<span>{{</span> user.id <span>}}</span> -- 名字：<span>{{</span> user.name <span>}}</span> -- 索引：<span>{{</span>i<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n \n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">\n    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({\n      el: <span class="hljs-string">\'#app\'</span>,\n      data: {\n        list: [\n          { id: <span class="hljs-number">1</span>, name: <span class="hljs-string">\'zs1\'</span> },\n          { id: <span class="hljs-number">2</span>, name: <span class="hljs-string">\'zs2\'</span> },\n          { id: <span class="hljs-number">3</span>, name: <span class="hljs-string">\'zs3\'</span> },\n          { id: <span class="hljs-number">4</span>, name: <span class="hljs-string">\'zs4\'</span> }\n        ]\n      },\n      methods: {}\n    });\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n\n</code></pre>\n<p>8.3、v-for 循环对象</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>\n    <span class="hljs-comment">&lt;!-- 注意：在遍历对象身上的键值对的时候， 除了 有  val  key  ,在第三个位置还有 一个 索引  --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(val, key, i) in user"</span>&gt;</span>值是： <span>{{</span> val <span>}}</span> -- 键是： <span>{{</span>key<span>}}</span> -- 索引： <span>{{</span>i<span>}}</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n \n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">\n    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({\n      el: <span class="hljs-string">\'#app\'</span>,\n      data: {\n        user: {\n          id: <span class="hljs-number">1</span>,\n          name: <span class="hljs-string">\'Tony Stark\'</span>,\n          gender: <span class="hljs-string">\'男\'</span>\n        }\n      },\n      methods: {}\n    });\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n</code></pre>\n<p>8.4、v-for 循环数字</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>\n    <span class="hljs-comment">&lt;!-- in 后面我们放过普通数组，对象数组，对象，还可以放数字 --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"count in 10"</span>&gt;</span>这是第 <span>{{</span> count <span>}}</span> 次循环<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n \n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">\n    <span class="hljs-comment">// 创建 Vue 实例，得到 ViewModel</span>\n    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({\n      el: <span class="hljs-string">\'#app\'</span>,\n      data: {},\n      methods: {}\n    });\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n\n</code></pre>\n<blockquote>\n<p>注意：如果使用 <code>v-for</code> 迭代数字的话，前面的 count 值从 1 开始。</p>\n</blockquote>\n<p>8.5、v-for 循环 key 属性</p>\n<p>key 属性可以使得每一遍历的项是唯一的。</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>\n \n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Id:\n        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"id"</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n \n      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Name:\n        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"name"</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n \n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"添加"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"add"</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n \n    <span class="hljs-comment">&lt;!-- 注意： v-for 循环的时候，key 属性只能使用 number或者string --&gt;</span>\n    <span class="hljs-comment">&lt;!-- 注意： key 在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 --&gt;</span>\n    <span class="hljs-comment">&lt;!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须在使用 v-for 的同时，指定 唯一的 字符串/数字 类型 :key 值 --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in list"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>&gt;</span><span>{{</span>item.id<span>}}</span> -- <span>{{</span>item.name<span>}}</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n \n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">\n    <span class="hljs-comment">// 创建 Vue 实例，得到 ViewModel</span>\n    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({\n      el: <span class="hljs-string">\'#app\'</span>,\n      data: {\n        id: <span class="hljs-string">\'\'</span>,\n        name: <span class="hljs-string">\'\'</span>,\n        list: [\n          { id: <span class="hljs-number">1</span>, name: <span class="hljs-string">\'李斯\'</span> },\n          { id: <span class="hljs-number">2</span>, name: <span class="hljs-string">\'嬴政\'</span> },\n          { id: <span class="hljs-number">3</span>, name: <span class="hljs-string">\'赵高\'</span> },\n          { id: <span class="hljs-number">4</span>, name: <span class="hljs-string">\'韩非\'</span> },\n          { id: <span class="hljs-number">5</span>, name: <span class="hljs-string">\'荀子\'</span> }\n        ]\n      },\n      methods: {\n        add() { <span class="hljs-comment">// 添加方法</span>\n          <span class="hljs-keyword">this</span>.list.unshift({ id: <span class="hljs-keyword">this</span>.id, name: <span class="hljs-keyword">this</span>.name })\n        }\n      }\n    });\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n\n</code></pre>\n<h3>9、v-if/v-show</h3>\n<p>v-if 和 v-show 都可以控制元素的显示与否。但是实现原理不同。</p>\n<p>v-if：决定某些元素是否存在 (加载性能更高,某个元素不需要被频繁切换时,则应该使用v-if)</p>\n<p>v-show：决定某些元素是否显示 (操作性能更高,如果某个元素需要被频繁切换,则应该使用v-show)</p>\n<blockquote>\n<p><code>v-if</code>：每次都会重新删除或创建元素。\n<code>v-show</code> ： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式。</p>\n</blockquote>\n<p>所以，如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show；</p>\n<p>如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if。</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"true"</span>&gt;</span>这是用v-if控制的元素<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"true"</span>&gt;</span>这是用v-show控制的元素<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>\n\n</code></pre>\n<blockquote>\n<p>有了v-if就有v-else-if和v-else<br>\nv-if和v-show指令中除了可以放简单的值外，还可以放表达式</p>\n</blockquote>\n<pre><code class="language-html">\n<span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"age &lt; 18"</span>&gt;</span>这是用v-if控制的元素<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>    <span class="hljs-comment">&lt;!--age是data中的一个属性--&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"age &lt; 28"</span>&gt;</span>这是用v-if控制的元素<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>    \n<span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">v-else</span>&gt;</span>这是用v-if控制的元素<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span> <span class="hljs-comment">&lt;!--v-else不用写条件--&gt;</span>\n\n</code></pre>\n<blockquote>\n<p>注意：v-if和v-else-if和v-else之间，不要加任何其他元素，否则会报错。</p>\n</blockquote>\n</section>\n'},320:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: vue组件开发props验证,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: vue,\ndate: 2019-05-08 14:51:53,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<h4>props为啥要验证一下</h4>\n<ol>\n<li>它们写明了组件的API,所以很容易看懂组件的用法</li>\n<li>在开发环境中，如果向一个组件提供格式不正确的prop，Vue将会警告，可以帮助我们捕获潜在的错误来源。</li>\n</ol>\n<h3>type</h3>\n<p>可以使用type来声明这个参数可以接受的数据的类型，当检查规则只有一个的时候type可以略写\ntype能够指定的类型\nString、Number、Boolean、Functio、Object、Array、Symbol</p>\n<pre><code class="language-js">    props: {\n        <span class="hljs-attr">fooMessage</span>: {\n            <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>,\n        }\n    }\n</code></pre>\n<h3>required</h3>\n<p>可以使用required选项来声明这个参数是否必须传入</p>\n<pre><code class="language-js">    props: {\n        <span class="hljs-attr">fooMessage</span>: {\n            <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>,\n            <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>\n        }\n    }\n</code></pre>\n<h3>default</h3>\n<p>使用default选项来指定当前父组件未传入参数时props变量的默认值</p>\n<pre><code class="language-js">    props: {\n        <span class="hljs-attr">fooMessage</span>: {\n            <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,\n            <span class="hljs-attr">default</span>: <span class="hljs-string">"我是默认信息"</span>\n        }\n    }\n</code></pre>\n<blockquote>\n<p>当type的类型为Array或者Object的时候default必须是一个函数：</p>\n</blockquote>\n<pre><code class="language-js">    props: {\n        <span class="hljs-attr">fooMessage</span>: {\n            <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>,\n            <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n                <span class="hljs-keyword">return</span> [<span class="hljs-string">"yes"</span>, <span class="hljs-string">"no"</span>];\n            }\n        }\n    }\n</code></pre>\n<h4><font color="red">JS中对象和数组是引用类型，指向同一个内存空间，如果 props 是一个对象或数组，在子组件内部改变它会影响父组件的状态</font> <a href="https://www.fudaqiang.com/2019/05/07/js基本数据类型和引用数据类型的区别/" target="_blank">不懂就点我吧</a></h4>\n<h3>validator</h3>\n<p>当效验规则很复杂，默认提供的效验规则无法满足的时候可以使用自定义函数来效验。</p>\n<pre><code class="language-js">props: {\n    <span class="hljs-attr">fooMessage</span>: {\n        <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>{\n            <span class="hljs-keyword">return</span> value&gt;=<span class="hljs-number">0</span> &amp;&amp; value&lt;=<span class="hljs-number">128</span>;\n        }\n    }\n}\n</code></pre>\n<h3>一个综合的例子</h3>\n<pre><code class="language-js">props: {\n    <span class="hljs-comment">// fooA只接受数值类型的参数</span>\n    fooA: <span class="hljs-built_in">Number</span>,\n    <span class="hljs-comment">// fooB可以接受字符串和数值类型的参数</span>\n    fooB: [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Number</span>],\n    <span class="hljs-comment">// fooC可以接受字符串类型的参数，并且这个参数必须传入</span>\n    fooC: {\n        <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,\n        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>\n    },\n    <span class="hljs-comment">// fooD接受数值类型的参数，如果不传入的话默认就是100</span>\n    fooD: {\n        <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>,\n        <span class="hljs-attr">default</span>: <span class="hljs-number">100</span>\n    },\n    <span class="hljs-comment">// fooE接受对象类型的参数</span>\n    fooE: {\n        <span class="hljs-attr">type</span>: <span class="hljs-built_in">Object</span>,\n        <span class="hljs-comment">// 当为对象类型设置默认值时必须使用函数返回</span>\n        <span class="hljs-keyword">default</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n            <span class="hljs-keyword">return</span> { <span class="hljs-attr">message</span>: <span class="hljs-string">\'Hello, world\'</span> }\n        }\n    },\n    <span class="hljs-comment">// fooF使用一个自定义的验证器</span>\n    fooF: {\n        <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>{\n            <span class="hljs-keyword">return</span> value&gt;=<span class="hljs-number">0</span> &amp;&amp; value&lt;=<span class="hljs-number">100</span>;\n        }\n    }\n}\n\n</code></pre>\n</section>\n'},321:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: vue组件的data为什么是函数而不是对象,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: vue,\ndate: 2019-05-08 11:08:53,\ntags: ,\nkeywords: ,\ndescription: Vue组件中为什么data是一个函数，为什么根实例的data是一个对象呢\n</header>\n---\n<h2>Vue组件中为什么data是一个函数</h2>\n<p>当在组件中使用<code>data</code>属性的时候（除了new Vue 外的任何地方），它的值<font color="red">必须是返回一个对象的函数</font>。既然必须返回一个对象，为什么data不直接使用对象呢</p>\n<pre><code>当data的值是一个对象时，它会在这个组件的所有实例之间共享。想象一下，假如一个 TodoList 组件的数据是这样的：\n</code></pre>\n<pre><code class="language-js">Vue.component(<span class="hljs-string">\'some-comp\'</span>, {\n    <span class="hljs-attr">data</span>: {\n        <span class="hljs-attr">listTitle</span>: <span class="hljs-string">\'\'</span>,\n        <span class="hljs-attr">todos</span>: []\n    }\n})\n</code></pre>\n<p>我们可能希望重用这个组件，允许用户维护多个列表（比如购物、收藏、日常事务等）。这时就会产生问题。因为每个组件的实例都引用了相同的数据对象，更改其中一个列表的标题就会改变每一个组件的标题。增删改也是如此。<a href="https://www.fudaqiang.com/js基本数据类型和引用数据类型的区别.html" target="_blank">不懂就点我吧</a></p>\n<p>取而代之的是，我们希望每一个组件实例都管理着自己的数据，为了做到这一点，每个实例必须生成一个独立的数据对象。在javascript中，在一个函数中返回这个对象就可以了：</p>\n<pre><code class="language-js">Vue.component(<span class="hljs-string">\'some-comp\'</span>, {\n    <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n        <span class="hljs-keyword">return</span> {\n            <span class="hljs-attr">foo</span>: <span class="hljs-string">\'bar\'</span>\n        }\n    }\n})\n</code></pre>\n<h3>为什么根实例的data是一个对象呢</h3>\n<pre><code class="language-js"><span class="hljs-keyword">new</span> Vue({\n    <span class="hljs-attr">data</span>: {\n        <span class="hljs-attr">foo</span>: <span class="hljs-string">\'bar\'</span>\n    }\n})\n</code></pre>\n<p>因为在Vue中只有一个实例，所以在vue的根实例上可以直接使用对象</p>\n<p><font color="red"></font></p>\n</section>\n'},322:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: vue自定义指令,\ncategories: 技术,\npath: /archives,\ncomments: true,\ndate: 2019-06-09 13:52:01,\ntags: ,\nkeywords: ,\nphotos: vue,\ndescription: \n</header>\n---\n<h3>Vue自定义指令</h3>\n<p><a href=\'https://www.fudaqiang.com/Vue指令.html\' target=\'brank\'>Vue指令</a>有很多,自己也可以根据业务逻辑抽象出来自己的指令\nvue指令和vue过滤器很相似</p>\n<h4>全局自定义指令</h4>\n<p>注册一个全局自定义指令 <code>v-focus</code>\n<a href=\'https://www.fudaqiang.com/vue-filter自定义过滤器.html#一、全局过滤器\' target=\'brank\'>vue全局过滤器</a></p>\n<pre><code class="language-js">Vue.directive(<span class="hljs-string">\'focus\'</span>, {\n    <span class="hljs-comment">// 当被绑定的元素插入到 DOM 中时……</span>\n    inserted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>{\n        el.focus();\n    }\n})\n&lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">v-focus</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n</code></pre>\n<h4>组件自定义指令</h4>\n<p>注册一个组件自定义指令 <code>v-focus</code>\n<a href=\'https://www.fudaqiang.com/vue-filter自定义过滤器.html#二、组件过滤器\' target=\'brank\'>vue局部过滤器</a></p>\n<pre><code class="language-js">&lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">v-focus</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    data() {\n        <span class="hljs-keyword">return</span> {\n            <span class="hljs-attr">msg</span>: <span class="hljs-string">\'About页\'</span>\n        };\n    },\n    <span class="hljs-attr">directives</span>: {\n        <span class="hljs-attr">focus</span>: {\n            <span class="hljs-comment">// 指令的定义</span>\n            inserted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>{\n                <span class="hljs-comment">// el是DOM元素input 你可以对当前input进行各种原生攻击</span>\n                el.focus();\n            }\n        }\n    }\n}\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>\n</code></pre>\n<h4>自定义指令传参</h4>\n<p>虽然能拿到当前DOM，能进行各种DOM输出。操作总觉得少了点，花样也不够多，玩法也不够新颖，逼格还是缺点高度。\n<a href=\'https://www.fudaqiang.com/vue-filter自定义过滤器.html#二、组件过滤器\' target=\'brank\'>vue过滤器传参</a></p>\n<pre><code class="language-js">&lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"about"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>About页<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-my-html</span>=<span class="hljs-string">"{data: $data,getApi}"</span>&gt;</span>\n            <span>{{</span> text <span>}}</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"dataList.length"</span>&gt;</span>\n            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in dataList"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>&gt;</span>\n                <span>{{</span> item <span>}}</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n<span class="hljs-keyword">import</span> {mapActions, mapGetters} <span class="hljs-keyword">from</span> <span class="hljs-string">\'vuex\'</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    data() {\n        <span class="hljs-keyword">return</span> {\n            <span class="hljs-attr">text</span>: <span class="hljs-string">\'哈哈哈哈哈哈\'</span>\n        };\n    },\n    <span class="hljs-attr">computed</span>: {\n        ...mapGetters([\n            <span class="hljs-string">\'user\'</span>\n        ]),\n        dataList() {\n            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.user.list;\n        }\n    },\n    <span class="hljs-attr">directives</span>: {\n        <span class="hljs-attr">myHtml</span>: {\n            inserted(el, binding, VNode) {\n                setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n                    el.innerHTML = <span class="hljs-string">\'hahaha\'</span>;\n                    <span class="hljs-comment">// binding.value.data.text = \'hahaha\';</span>\n                    <span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();\n                    <span class="hljs-built_in">console</span>.log(el.innerHTML, date.toLocaleString());\n                }, <span class="hljs-number">1000</span>);\n                setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n                    el.innerHTML = <span class="hljs-string">\'xixixi\'</span>;\n                    <span class="hljs-comment">// binding.value.data.text = \'xixixi\';</span>\n                    <span class="hljs-comment">// VNode.context.updateText(); </span>\n                    <span class="hljs-comment">// VNode.context.getApi();</span>\n                    <span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();\n                    <span class="hljs-built_in">console</span>.log(el.innerHTML, date.toLocaleString());      \n                }, <span class="hljs-number">3000</span>);\n            },\n            update(newValue, oldValue) {\n                <span class="hljs-built_in">console</span>.log(newValue, <span class="hljs-string">\'update\'</span>);\n                <span class="hljs-comment">// 根据获得的新值执行对应的更新</span>\n            },\n            unbind() {\n                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'清理工作\'</span>);\n                <span class="hljs-comment">// 当前组件销毁时执行 做清理工作</span>\n            }\n        }\n    },\n    mounted() {\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'mounted\'</span>);\n    },\n    beforeUpdate() {\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'--beforeUpdate\'</span>);\n    },\n    updated() {\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'--updated\'</span>);\n    },\n    <span class="hljs-attr">methods</span>: {\n        ...mapActions([\n            <span class="hljs-string">\'getApi\'</span>\n        ]),\n        updateText() {\n            <span class="hljs-keyword">this</span>.text = <span class="hljs-string">\'嘻嘻嘻嘻嘻\'</span>;\n        }\n    }\n};\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>\n</code></pre>\n<p><img src="https://cdn.jsdelivr.net/gh/qiang520184/cdn@1.4.4/images/vue/zhiling.png" alt="zhiling">;</p>\n<p>用指令获取到当前DOM,对其修改DOM改变了。是不会触发vue两个生命周期<code>beforeUpdate</code> <code>updated</code>。\n只有当vue data返回的数据或vuex数据发生改变的时候才会触发<code>beforeUpdate</code> <code>updated</code> 执行</p>\n<h3>binding</h3>\n<p><code>v-my-html=&quot;{data: $data,getApi}&quot;</code> 自定义指令等号后面面是一个对象，key,value 键值对的形式传参\n传过来的参数在指令第二个参数 <code>binding.value</code> 里面</p>\n<h3>VNode</h3>\n<p><img src="https://cdn.jsdelivr.net/gh/qiang520184/cdn@1.4.4/images/vue/VNodeContext.png" alt="zhiling">;\n<img src="https://cdn.jsdelivr.net/gh/qiang520184/cdn@1.4.4/images/vue/VNode.png" alt="zhiling">;\n指令第三个参数VNode，VNode就是虚拟DOM的js对象。 在指令中直接使用this是不行的， console.log(this)结果是<code>undefined</code>。 但是在VNode.context就当前组件的this对象。\n你可以VNode.context 去执行 methods生命周期里面的函数,可以跳转路由。this能干的事情他都能干。</p>\n</section>\n'},323:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: javascript 严格模式,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: javascript,\ndate: 2019-04-09 08:42:16,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<h3>一、ECMAScript 5 严格模式</h3>\n<h3>1、概述</h3>\n<p>除了正常运行模式，ECMAscript 5添加了第二种运行模式：&quot;严格模式&quot;（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。</p>\n<h3>2、目的</h3>\n<ul>\n<li>\n<p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</p>\n</li>\n<li>\n<p>消除代码运行的一些不安全之处，保证代码运行的安全；</p>\n</li>\n<li>\n<p>提高编译器效率，增加运行速度；</p>\n</li>\n<li>\n<p>为未来新版本的Javascript做好铺垫。</p>\n</li>\n</ul>\n<p>&quot;严格模式&quot;体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。</p>\n<p>另一方面，同样的代码，在&quot;严格模式&quot;中，可能会有不一样的运行结果；一些在&quot;正常模式&quot;下可以运行的语句，在&quot;严格模式&quot;下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。</p>\n<h3>3、使用</h3>\n<p>1、将&quot;use strict&quot;放在脚本文件的第一行，则整个脚本都将以&quot;严格模式&quot;运行。**如果这行语句不在第一行，则无效，整个脚本以&quot;正常模式&quot;运行。**如果不同模式的代码文件合并成一个文件，这一点需要特别注意。</p>\n<p>(严格地说，只要前面不是产生实际运行结果的语句，&quot;use strict&quot;可以不在第一行，比如直接跟在一个空的分号后面。)</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-meta">\n\t"use strict"</span>;\n\t<span class="hljs-comment">//...</span>\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p>2、针对单个函数</p>\n<p>将&quot;use strict&quot;放在函数体的第一行，则整个函数以&quot;严格模式&quot;运行。</p>\n<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strict</span>(<span class="hljs-params"></span>)</span>{\n<span class="hljs-meta">  "use strict"</span>;\n  <span class="hljs-keyword">return</span> <span class="hljs-string">"这是严格模式。"</span>;\n}\n</code></pre>\n<h2>二、语法和行为改变</h2>\n<h3>1、全局变量必须用var显示声明变量</h3>\n<p>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p>\n<pre><code class="language-html">\t<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="hljs-meta">\n\t\t"use strict"</span>;　　\n\t\tv = <span class="hljs-number">1</span>; <span class="hljs-comment">// 报错，v未声明</span>\n\t\t<span class="hljs-comment">//name = "Daotin";</span>\n\t\t<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) { <span class="hljs-comment">// 报错，i未声明</span>\n\t\t}\n\t</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<blockquote>\n<p>不能使用 name，因为 name 是window的一个保留属性，默认为空。</p>\n</blockquote>\n<h3>2、禁止自定义的函数中的this指向window</h3>\n<pre><code class="language-html">\t<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-meta">\n\t\t"use strict"</span>;　　\n\t\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{\n\t\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);\n\t\t}\n\t\tfoo();\n\t</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p>没有 &quot;use strict&quot; 的时候，打印 window对象，有 &quot;use strict&quot; 的时候，打印undefined。</p>\n<h3>3、严格模式会创建eval作用域</h3>\n<p>eval会解析语句中的字符串。</p>\n<pre><code class="language-html">\t<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-meta">\n\t\t"use strict"</span>;　　\n\t\t<span class="hljs-keyword">var</span> name = <span class="hljs-string">\'Daotin\'</span>;\n\t\t<span class="hljs-built_in">eval</span>(<span class="hljs-string">\'var name = "lvonve"; console.log(name)\'</span>);\n\t\t<span class="hljs-built_in">console</span>.log(name);\n\t</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p>如果不加 &quot;use strict&quot;; ，两次打印的结构都为 lvonve；加了的话，打印结果为 lvonve和Daotin。也就相当于给eval创建了一个作用域。</p>\n<h3>4、对象不能有重名的属性</h3>\n<p>正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。</p>\n<p>（但是在浏览器console下面并没有显示错误信息。）</p>\n<pre><code class="language-html">\t<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-meta">\n\t\t"use strict"</span>;　　\n\t\t<span class="hljs-keyword">var</span> o = {　　　　\n\t\t\t<span class="hljs-attr">p</span>: <span class="hljs-number">1</span>,\n\t\t\t<span class="hljs-attr">p</span>: <span class="hljs-number">2</span>　　\n\t\t}; <span class="hljs-comment">// 语法错误</span>\n\t</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h3>5、禁止删除变量</h3>\n<p>严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。</p>\n<pre><code class="language-js"><span class="hljs-meta">"use strict"</span>;\n　　<span class="hljs-keyword">var</span> x;\n　　<span class="hljs-keyword">delete</span> x; <span class="hljs-comment">// 语法错误</span>\n　　<span class="hljs-keyword">var</span> o = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>, {<span class="hljs-string">\'x\'</span>: {\n　　　　　　<span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,\n　　　　　　<span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>\n　　<span>}}</span>);\n　　<span class="hljs-keyword">delete</span> o.x; <span class="hljs-comment">// 删除成功</span>\n</code></pre>\n</section>\n'},324:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: 前端常问面试题,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: javascript,\ndate: 2019-04-20 18:28:54,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<h4><font color="red">一、先做个自我介绍吧</font></h4>\n<p>  吧啦吧啦就说一些...</p>\n<h4><font color="red">二、css相关问题</font></h4>\n<p>1.<font color="red">盒模型</font>\n  CSS中主要有以下盒模型：inline、inline-block、block、table、position、float。浏览器把每个元素看作一个盒模型，每个盒模型由以下几个属性组合决定的：display、position、float、width、height、margin、padding和border等，不同的盒模型会产生不同的布局</p>\n<p>盒模型分为两种：标准盒模型、怪异盒模型</p>\n<p>标准盒模型</p>\n<pre><code>        外盒尺寸计算:\n            Element高度 = 内容高度 + 填充 + 边框 + 外边距\n            Element宽度 = 内容宽度 + 填充 + 边框 + 外边距\n        内盒尺寸计算:\n            Element高度 = 内容高度 + 填充 + 边框\n            Element宽度 = 内容宽度 + 填充 + 边框\n</code></pre>\n<p>怪异盒模型</p>\n<pre><code>        外盒尺寸计算\n            Element高度 = 内容高度 + 外距（height包含了元素内容高度、边框、填充）\n            Element宽度 = 内容宽度 + 外距（width包含了元素内容宽度、边框、填充）\n        内盒尺寸计算\n            Element高度 = 内容高度（height包含了元素内容高度、边框、填充）\n            Element宽度 = 内容宽度（width包含了元素内容宽度、边框、填充）\n</code></pre>\n<p><font color="red">无论使用哪种模式完整定义DOCTYPE，都会触发标准模式，而如果DOCTYPE缺失则在ie6，ie7，ie8下将会触发怪异模式（quirks 模式）</font>\ncss3新增盒模型属性box-sizing，能够事先定义盒模型的尺寸解析方式</p>\n<p><font color="red">box-sizing:content-box | border-box | inherit</font></p>\n<p>参数说明：</p>\n<p>  <font color="red">content-box</font>：默认值，让元素维持W3C标准盒模型<br /><br>\n  <font color="red">border-box</font>：让元素维持IE传统的盒模型（IE6以下版本盒IE6~7怪异模式）<br />\n  <font color="red">inherit</font>：使元素继承父元素的盒模型模式。\n老版本浏览器存在兼容问题：\n1、-moz-    firefox浏览器\n2、-ms-     ie浏览器\n3、-webkit- safari、chrome\n4、-o-      Opera</p>\n<p>2.阴影<font color="red">box-shadow</font>\nbox-shadow: x y blur spread color inset;\n  参数说明:\n  X       <font color="red">必需</font>。水平阴影的位置。允许负值\n  y       <font color="red">必需</font>。垂直阴影的位置。允许负\n  blur\t可选。模糊距离。\t\n  spread\t可选。阴影的尺寸。\t\n  color\t可选。阴影的颜色。请参阅 CSS 颜色值。\t\n  inset   可选。将外部阴影 (outset) 改为内部阴影。\n<font color="red">box-reflect</font>：倒影\n  语法: box-reflect：none | <font color="skyblue">direction offset </font>?  <font color="skyblue">mask-box-image</font>\n    <font color="skyblue">direction</font> = above | below | left | right\n    <font color="skyblue">offset</font> = length | percentage\n    <font color="skyblue">mask-box-image</font> =  none | url | linear-gradient | radial-gradient | repeating-linear-gradient | repeating-radial-gradient</p>\n<p>  参数说明:</p>\n<p><font color="skyblue">direction</font>：方向  （必选参数）above | below | left | right\n    above：指定倒影在对象的上边\n    below：指定倒影在对象的下边\n    left：指定倒影在对象的左边\n    right：指定倒影在对象的右边\n<font color="skyblue">offset</font>\n    可用长度值来定义倒影与对象之间的间隔。可以为负值\n    可用百分比来定义倒影与对象之间的间隔。可以为负值\n<font color="skyblue">mask-box-image</font>\n    url：使用绝对或相对地址指定遮罩图像。\n    linear-gradient：使用线性渐变创建遮罩图像。\n    radial-gradient：使用径向(放射性)渐变创建遮罩图像。\n    repeating-linear-gradient：使用重复的线性渐变创建背遮罩像。\n    repeating-radial-gradient：使用重复的径向(放射性)渐变创建遮罩图像。\n3、<font color="red">弹性盒</font>\n<font color="skyblue">flex-direction属性</font></p>\n<p>  flex-direction 属性指定了弹性子元素在父容器中的位置。\n  语法：flex-direction: row | row-reverse | column | column-reverse</p>\n<p>  参数说明:</p>\n<p>    row：横向从左到右排列（左对齐），默认的排列方式</p>\n<p>    row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面）</p>\n<p>    column：纵向排列</p>\n<p>    column-reverse：反转纵向排列，从后往前排，最后一项排在最上面</p>\n<p><font color="skyblue">justify-content 属性</font></p>\n<p>  justify-content属性表示内容对齐，应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐</p>\n<p>  语法：justify-content: flex-start | flex-end | center | space-between | space-around</p>\n<p>  参数说明:</p>\n<p>    flex-start：项目位于容器的开头，默认值。</p>\n<p>    flex-end：项目位于容器的结尾</p>\n<p>    center：项目位于容器的中心</p>\n<p>    space-between：项目位于各行之间留有空白的容器内</p>\n<p>    space-around：项目位于各行之前、之间、之后都留有空白的容器内</p>\n<p><font color="skyblue">align-items 属性</font></p>\n<p>  align-items 属性设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。</p>\n<p>  语法:align-items: flex-start | flex-end | center | baseline | stretch</p>\n<p>  参数说明:</p>\n<p>    flex-start：元素位于容器的开头</p>\n<p>    flex-end：元素位于容器的结尾</p>\n<p>    center：元素位于容器的中心</p>\n<p>    baseline：元素位于容器的基线上</p>\n<p>    stretch：默认值。元素被拉伸以适应容器</p>\n<p><font color="skyblue">flex-wrap 属性</font></p>\n<p>flex-wrap 属性用于指定弹性盒子的子元素换行方式。</p>\n<p>  CSS语法</p>\n<p>flex-wrap: nowrap|wrap|wrap-reverse|initial|inherit;\nnowrap：默认，弹性容器为单行，该情况下弹性子项可能会溢出容器。</p>\n<p>    wrap ：弹性容器为多行，该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行</p>\n<p>    wrap-reverse ：反转 wrap 排列</p>\n<p><font color="skyblue">align-content 属性</font></p>\n<p>align-content 属性用于修改 flex-wrap 属性的行为。用于设置各个行的对齐</p>\n<p>语法: align-content: flex-start | flex-end | center | space-between | space-around | stretch\n  参数说明:</p>\n<p>    stretch ：各行将会伸展以占用剩余的空间，默认值</p>\n<p>    flex-start：各行向弹性盒容器的起始位置堆叠</p>\n<p>    flex-end： 各行向弹性盒容器的结束位置堆叠</p>\n<p>    center ：各行向弹性盒容器的中间位置堆叠</p>\n<p>    space-between：各行在弹性盒容器中平均分布</p>\n<p>    space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半</p>\n<p>4、<font color="red">溢出文本省略号</font>\n单行文本省略号\n.text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap\n}\n多行文本省略号\n.test {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2; //文本显示多少行\n  -webkit-box-orient: vertical;\n}</p>\n<p>伪类实现省略号\n.txt:after {\n  content: &quot;...&quot;;\n}</p>\n<p><font color="red">5、css选择器</font>\n<font color="skyblue">基本选择器</font><br>\n  *\t 通配选择器\n  div\t 元素选择器\n  #id\t ID选择器\n  .class\t 类选择器\n  div,p\t 群组选择器\n<font color="skyblue">层次选择器语法</font>\n  div p\t后代选择器         选择div下所有的元素p\n  div&gt;p\t子选择器           选择div下所有的直属子元素p\n  div+p\t相邻兄弟选择器      选择匹配的p元素，且匹配的p元素紧位于匹配的div元素的后面\n  div~p\t通用选择器         选择匹配的p元素，且位于匹配的div元素后的所有匹配的p元素\n<font color="skyblue">结构伪类选择器</font>\n  div:fisrt-child\t作为父元素的第一个子元素的元素div。与div:nth-child(1)等同\n  div:last-child\t作为父元素的最后一个子元素的元素E。与div:nth-last-child(1)等同\n  ul li:nth-child(n) 选择父元素ul的第n个子元素li。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0\n  ul li:nth-last-child(n)\t选择父元素ul的倒数第n个子元素li。此选择器与ul:nth-child(n)选择器计算顺序刚好相反，但使用方法都是一样的，其中：nth-last-child(1)始终匹配最后一个元素，与last-child等同\n  div:nth-of-type(n)\t选择父元素内具有指定类型的第n个div元素\n  div:nth-last-of-type(n)\t选择父元素内具有指定类型的倒数第n个div元素\n  div:first-of-type\t选择父元素内具有指定类型的第一个div元素，与div:nth-of-type(1)等同\n  div:last-of-tye\t    选择父元素内具有指定类型的最后一个div元素，与div:nth-last-of-type(1)等同\n  div:only-child\t    选择父元素只包含一个子元素，且该子元素匹配div元素\n  div:only-of-type    选择父元素只包含一个同类型子元素，且该子元素匹配div元素\n  div:empty\t        选择没有子元素的元素，而且该元素也不包含任何文本节点\n<font color="skyblue">否定伪类选择器</font>\n  div:not(p)\t匹配所有除元素p外的div元素\n<font color="skyblue">事件伪类选择器</font>\n  a:link\t        选择所有未访问链接\t\n  a:visited       选择所有访问过的链接\t\n  a:active\t    选择活动链接\t\n  a:hover\t        选择鼠标在链接上面时\t\n  input:focus\t    选择具有焦点的输入元素\n  input:checked\t选择每个选中的输入元素\n  input:disabled\t选择每一个禁用的输入元素\n  input:enabled\t选择每一个已启用的输入元素\n<font color="skyblue">属性选择器语法</font>\n  [attribute]\t用于选取带有指定属性的元素。\n  [attribute=value]\t用于选取带有指定属性和值的元素。\n  [attribute~=value]\t用于选取属性值中包含指定词汇的元素。\n  [attribute|=value]\t用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。\n  [attribute^=value]\t匹配属性值以指定值开头的每个元素。\n  [attribute$=value]\t匹配属性值以指定值结尾的每个元素。\n  [attribute*=value]\t匹配属性值中包含指定值的每个元素。</p>\n<p><font color="red">6、CSS优先级</font></p>\n<p>!important 的权值最高 10000。<font color="red">谨慎使用！！！</font></p>\n<p>内联样式表的权值为 1000。</p>\n<p>ID 选择器的权值为 100。</p>\n<p>Class | 伪类 | 属性 选择器的权值为 10。</p>\n<p>HTML 标签（类型）选择器的权值为 1。</p>\n<p>通配符选择器的权值为 0。</p>\n<p><font color="red">权重值相同的情况下,后写的样式会覆盖前面的样式</font>\n<font color="red">6、子盒子水平垂直居中</font></p>\n<ol>\n<li>\n<p>弹性盒\n.parent{\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}</p>\n</li>\n<li>\n<p>margin</p>\n<p>.children{\n  margin: calc(父元素高度一半 - 自身高度一半) auto;\n}</p>\n</li>\n<li>\n<p>绝对定位</p>\n<p>.parent{\n  position: relative;\n}\n.children{\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  margin: auto;\n}</p>\n</li>\n<li>\n<p>相对定位</p>\n<ol>\n<li>配合margin\n.children{\n  margin: calc(父元素高度一半) auto;\n  position: relative;\n  top: calc(自身高度一半);\n}</li>\n<li>.children{\n  position: relative;\n  top: calc(父元素高度一半 - 自身高度一半)\n  left: calc(父元素高度一半 - 自身高度一半)\n}</li>\n</ol>\n</li>\n<li>\n<p>表格</p>\n<p>.parent{\n  display: table-cell;\n  vertical-align: middle;\n}\n.children{\n   margin: 0 auto;\n}</p>\n</li>\n<li>\n<p>transform: translate 位移</p>\n<p>.childrn{\n  transform: translate3D(calc(父元素高度一半 - 自身高度一半),calc(父元素高度一半 - 自身高度一半),0)\n}</p>\n</li>\n</ol>\n<h4><font color="red">三、html相关问题</font></h4>\n<h4><font color="red">四、js相关问题</font></h4>\n<ol>\n<li>js数据类型</li>\n<li>如何检测数据类型</li>\n<li>null 和 undfined 区别</li>\n<li>堆和栈</li>\n<li>操作数组的方法</li>\n<li>不会修改原数组的方法</li>\n<li>深拷贝</li>\n<li>JSON.parse(JSON.stringify(obj)) 有什么缺陷</li>\n<li>this</li>\n<li>call、apply、bind 区别</li>\n<li>严格模式</li>\n<li>闭包</li>\n<li>如解决内存泄露</li>\n<li>浏览器垃圾回收机制</li>\n<li>重绘回流</li>\n<li>性能优化</li>\n<li>promise,和setTimeout区别</li>\n<li>异步队列 event loop</li>\n<li>ajax,axios,fetch区别</li>\n<li>跨域</li>\n</ol>\n<h4><font color="red">五、算法题</font></h4>\n<pre><code>1. 求1+N的和 用递归实现\n2. 斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 求第N位结果\n</code></pre>\n<h4><font color="red">五、项目相关问题</font></h4>\n<h4><font color="red">六、开发遇到的问题</font></h4>\n<h4><font color="red">七、学习问题</font></h4>\n<ol>\n<li>你喜欢关注新技术吗</li>\n<li>最近有专研什么技术吗</li>\n<li>你学习都是如何去学习</li>\n</ol>\n<p><font color="skyblue"></font>\n<font color="red"></font></p>\n</section>\n'},325:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: 封装promise,\ncategories: 技术,\npath: /archives,\ncomments: true,\ndate: 2019-05-29 21:26:58,\ntags: ,\nkeywords: ,\nphotos: javascript,\ndescription: \n</header>\n---\n<h3>分析一下promise吧</h3>\n<ol>\n<li>promise 有三个状态 <code>pending</code> （准备状态）、<code>fulfilled</code>（成功状态）、<code>rejected</code>（失败状态） 并且状态是不可逆的</li>\n<li>promise 接受一个函数作为参数函数包含（两个函数作为参数<code>resolve</code> <code>reject</code>）</li>\n<li>promise 实例生成后，可以用then方法指定<code>resolve</code> 和<code>reject</code> 的回调函数</li>\n<li>promise.then() 返回一个新的promise实例 如果.then接受的参数不是函数，那么它的结果就会放到下一次.then执行</li>\n</ol>\n<h3>一个很 low的promise调用一下看看吧</h3>\n<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>{\n    <span class="hljs-keyword">constructor</span>(fn) {\n        <span class="hljs-keyword">this</span>.state = <span class="hljs-string">\'pending\'</span>;\n        <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;\n        <span class="hljs-keyword">this</span>.successFnArray = [];\n        <span class="hljs-keyword">this</span>.errorFnArray = [];\n\n        <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> { <span class="hljs-comment">// resolve就做2件事情  1: 修改状态 2:调用successFn</span>\n            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">\'pending\'</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 限制状态不可逆</span>\n            <span class="hljs-keyword">this</span>.state = <span class="hljs-string">\'fulfilled\'</span>;\n            <span class="hljs-keyword">this</span>.value = res;\n            <span class="hljs-keyword">this</span>.successFnArray.forEach(<span class="hljs-function"><span class="hljs-params">successFn</span> =&gt;</span> {\n                successFn(res);\n            });\n        };\n        <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> { <span class="hljs-comment">// reject就做2件事情  1: 修改状态 2:调用errorFn</span>\n            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">\'pending\'</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 限制状态不可逆</span>\n            <span class="hljs-keyword">this</span>.state = <span class="hljs-string">\'rejected\'</span>;\n            <span class="hljs-keyword">this</span>.value = err;\n            <span class="hljs-keyword">this</span>.errorFnArray.forEach(<span class="hljs-function"><span class="hljs-params">errorFn</span> =&gt;</span> {\n                errorFn(err);\n            });\n        };\n        fn(resolve, reject);\n    }\n    then (successFn, errorFn) {\n        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &amp;&amp; <span class="hljs-keyword">typeof</span> successFn === <span class="hljs-string">\'function\'</span> || <span class="hljs-keyword">typeof</span> errorFn === <span class="hljs-string">\'function\'</span>) {\n            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n                <span class="hljs-keyword">const</span> _successFn = <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {\n                    resolve(successFn(res));\n                };\n                <span class="hljs-keyword">const</span> _errorFn = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {\n                    reject(errorFn(err));\n                };\n                <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) {\n                    <span class="hljs-keyword">case</span> <span class="hljs-string">\'fulfilled\'</span>:\n                        _successFn(<span class="hljs-keyword">this</span>.value);\n                        <span class="hljs-keyword">break</span>;\n                    <span class="hljs-keyword">case</span> <span class="hljs-string">\'rejected\'</span>:\n                        _errorFn(<span class="hljs-keyword">this</span>.value);\n                        <span class="hljs-keyword">break</span>;\n                    <span class="hljs-keyword">case</span> <span class="hljs-string">\'pending\'</span>:\n                        <span class="hljs-keyword">this</span>.successFnArray.push(successFn);\n                        <span class="hljs-keyword">this</span>.errorFnArray.push(errorFn);\n                        <span class="hljs-keyword">break</span>;\n                }\n            });\n        }\n        <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n                <span class="hljs-keyword">const</span> _successFn = <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {\n                    resolve(res);\n                };\n                <span class="hljs-keyword">const</span> _errorFn = <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {\n                    reject(error);\n                };\n                <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) {\n                    <span class="hljs-keyword">case</span> <span class="hljs-string">\'fulfilled\'</span>:\n                        _successFn(<span class="hljs-keyword">this</span>.value);\n                        <span class="hljs-keyword">break</span>;\n                    <span class="hljs-keyword">case</span> <span class="hljs-string">\'rejected\'</span>:\n                        _errorFn(<span class="hljs-keyword">this</span>.value);\n                        <span class="hljs-keyword">break</span>;\n                    <span class="hljs-keyword">case</span> <span class="hljs-string">\'pending\'</span>:\n                        <span class="hljs-keyword">this</span>.successFnArray.push(_successFn);\n                        <span class="hljs-keyword">this</span>.errorFnArray.push(_errorFn);\n                        <span class="hljs-keyword">break</span>;\n                }\n            });\n        }\n    }\n}\n\n<span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        resolve(<span class="hljs-string">\'resolve\'</span>);\n        <span class="hljs-comment">// reject(\'reject\');</span>\n    }, <span class="hljs-number">2000</span>);\n});\n\np.then(<span class="hljs-number">12</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(res);\n}, err =&gt; {\n    <span class="hljs-built_in">console</span>.log(err);\n}).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(res);\n}, err =&gt; {\n    <span class="hljs-built_in">console</span>.log(err);\n});\n\n</code></pre>\n<p>是不是很spicy chicken  哈哈</p>\n</section>\n'},326:function(n,l,t){"use strict";t.r(l),l.default="<section><hr>\n<header>\ntitle: 正则,\ncategories: 技术,\npath: /archives,\ncomments: true,\ndate: 2019-06-13 18:06:11,\ntags: ,\nkeywords: ,\ndescription: ,\nphotos: \n</header>\n---\n</section>\n"},327:function(n,l,t){"use strict";t.r(l),l.default="<section><hr>\n<header>\ntitle: 程序员语录,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: apple,\ndate: 2019-05-08 ,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<ol>\n<li>学习，是为了变成更好的自己， 将来的你，一定会感谢现在努力的自己！</li>\n<li>好的代码像粥一样，都是用时间熬出来的</li>\n<li>有志者自有千计万计，无志者只感千难万难。</li>\n<li>陪伴是最长情的告白，而会陪伴你的只有代码。</li>\n<li>天当被，地当床，只有代码在身旁。</li>\n</ol>\n</section>\n"},328:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: 翻墙YouTube看不停,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: google,\ndate: 2019-04-20 13:33:57,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n\x3c!-- [TOC] --\x3e\n<h1>翻墙</h1>\n<h2>1.国外服务器</h2>\n<h3>本人采用的<a href="https://www.vultr.com/?ref=8039983,%22vultr%22">Vultr</a>服务器</h3>\n<h3>mac 电脑直接 command+空格 输入终端 打开终端</h3>\n<h3>ssh root@ 你的国外服务器的IP</h3>\n<h3>输入你的服务器密码</h3>\n<pre><code class="language-js">yum -y install wget\nwget --no-check-certificate https:<span class="hljs-comment">//raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</span>\nchmod +x shadowsocksR.sh\n./shadowsocksR.sh <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> | tee shadowsocksR.log\n</code></pre>\n<h3>跟着提升一步步走</h3>\n<h3>看到下面这写的时候就已经成功了  复制下来保持起来</h3>\n<p>Congratulations, ShadowsocksR server install completed!\nYour Server IP        :  0.0.0.0\nYour Server Port      :  19216\nYour Password         :  teddysun.com\nYour Protocol         :  origin\nYour obfs             :  plain\nYour Encryption Method:  aes-256-cfb</p>\n<p>Welcome to visit:\nEnjoy it!</p>\n<p>[root@vultr shadowsocks-libev]#</p>\n<h3>已经成功啦</h3>\n<h3>mac电脑上下载一个<a href="http://www.emptyus.com/data/ssx-mac-v33.zip">shadowsocks</a></h3>\n<h3>windows电脑下载<a href="http://www.emptyus.com/data/ssx-win-v416.zip">shadowsocks点击这里</a></h3>\n<h3>把你的服务器地址、服务器端口、密码、加密方式、填完 就能翻墙了</h3>\n</section>\n'},329:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: 节流throttle,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: javascript,\ndate: 2019-04-20 18:31:40,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<pre><code class="language-js">\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>{\n      <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;\n      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n        <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span>\n        timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n          fn()\n          timer = <span class="hljs-literal">null</span>\n        }, wait)\n      };\n    };\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">11</span>)\n    }\n    setInterval(throttle(fn, <span class="hljs-number">2000</span>), <span class="hljs-number">100</span>);\n\n    setInterval(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"12"</span>)\n    },<span class="hljs-number">1000</span>);\n</code></pre>\n</section>\n'},330:function(n,l,t){"use strict";t.r(l),l.default='<section><hr>\n<header>\ntitle: 防抖debounce,\ncategories: 技术,\npath: /archives,\ncomments: true,\nphotos: javascript,\ndate: 2019-04-20 18:32:43,\ntags: ,\nkeywords: ,\ndescription: \n</header>\n---\n<pre><code class="language-js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>{\n      <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;\n      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n        <span class="hljs-keyword">if</span> (timer !== <span class="hljs-literal">null</span>){\n          clearTimeout(timer);\n           timer = <span class="hljs-literal">null</span>;\n        } \n        timer = setTimeout(fn, wait);\n      }\n    }\n</code></pre>\n</section>\n'},331:function(n,l,t){"use strict";var e=t(293);t.n(e).a},342:function(n,l,t){"use strict";t.r(l);t(117),t(169);var e={data:function(){return{}},computed:{testMd:function(){return this.$route.params.id?t(302)("./".concat(this.$route.params.id,".md")).default:"../../source/js闭包.md"},info:function(){var n={},l=this.testMd.slice(this.testMd.indexOf("<header>")+8,this.testMd.indexOf("</header>")).replace(/\s/g,"").split(",");return l&&l.length&&l.forEach(function(l){var t=l.split(":");n[t[0]]=t[1]&&t[1].trim()}),n},mdData:function(){return this.testMd&&this.testMd.slice(this.testMd.indexOf("</header>")+13)}}},c=(t(331),t(12)),component=Object(c.a)(e,function(){var n=this.$createElement,l=this._self._c||n;return l("div",[l("div",{staticClass:"skill"},[l("h1",{staticClass:"title"},[this._v(this._s(this.info.title))]),this._v(" "),l("pre",{staticClass:"markdown-body",domProps:{innerHTML:this._s(this.mdData)}})])])},[],!1,null,null,null);l.default=component.exports}}]);
//# sourceMappingURL=eb9e38185446bd333a78.js.map